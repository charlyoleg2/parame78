import{f as O,C as He,S as Ae,i as be,a as Me,b as a,p as xt,t as Tt,c as X,d as j,g as So,h as Le,j as Dt,E as et,k as Rt,w as Ro,l as s,m as z,n as ht,o as Ot,q as ft,r as p,u as bt,v as vt,x as Mt,y as G,z as Q,A as Pe,B as ie,D as Ao,F as Re}from"./C4uc3MhX.js";function St(o){return o.toFixed(2)}function Qt(o){let t=o;for(;t<-Math.PI;)t+=2*Math.PI;for(;t>Math.PI;)t-=2*Math.PI;return t}function xe(o){let t=!1;const i=10**-4;return Math.abs(o)<i&&(t=!0),t}function zt(o,t,i){let e="";if(i===0)throw`err${o}: ${t}`;return i===1&&(e+=`warn${o}: ${t}
`),e}function _e(o,t,i=0){let e="";const n=Qt(o);if(n<=0||xe(n)){const c=`${t} : a1 ${St(o)}, a1b ${St(n)} is null or negative`;e+=zt("145",c,i)}return e}function Et(o,t,i=0){let e="";if(o<=0||xe(o)){const n=`${t} : l1 ${St(o)} is null or negative`;e+=zt("159",n,i)}return e}function re(o,t,i=0){let e="";const n=Qt(o),c=Qt(t);if(e+=_e(n,"triAArA.a1",2),e+=_e(c,"triAArA.a2",2),Math.sign(o)*Math.sign(t)<0){const d=`triAArA : the signs of a1 ${St(o)} and a2 ${St(t)} differ`;e+=zt("178",d,i)}if(Math.abs(n)+Math.abs(c)>=Math.PI){const d=`triAArA : a1 ${St(o)} plus a2 ${St(t)} are bigger than Pi`;e+=zt("182",d,i)}return[Qt(Math.PI-o-t),e]}function Ve(o,t,i,e=0){let n="";const[c,g]=re(o,i,e);n+=g,n+=Et(t,"triALArLL.l12",e);let d=0,r=0;if(xe(c)){const l=`triALArLL : flat triangle with a1 ${St(o)}, a2 ${St(i)} and a3 ${St(c)}`;n+=zt("209",l,e),xe(o)?(d=0,r=t):(d=t,r=0)}else d=t*Math.sin(o)/Math.sin(c),r=t*Math.sin(i)/Math.sin(c);return[d,r,n]}function Yt(o,t,i,e=0){let n="";n+=Et(o,"triLALrL.l1",e),n+=_e(t,"triLALrL.a12",2),n+=Et(i,"triLALrL.l2",e);const c=o**2+i**2-2*o*i*Math.cos(t);if(c<0){const d=`triLALrL : ql3 ${St(c)} is negative with l1 ${St(o)}, a12 ${St(t)}, l2 ${St(i)}`;n+=zt("241",d,e)}return[Math.sqrt(c),n]}function je(o,t,i,e=0){let n="";n+=_e(o,"triALLrL.a31",2),n+=Et(t,"triALLrL.l1",e),n+=Et(i,"triALLrL.l2",e);const c=-2*t*Math.cos(o),g=t**2-i**2,d=c**2-4*g;if(d<0){const f=`triALLrL : qD ${St(d)} is negative with a31 ${St(o)}, l1 ${St(t)}, l2 ${St(i)}`;n+=zt("271",f,e)}const r=(-c-Math.sqrt(d))/2,l=(-c+Math.sqrt(d))/2;return n+=Et(r,"triALLrL.rx1",2),n+=Et(l,"triALLrL.rx2",2),[r,l,n]}function xo(o,t,i,e=0){let n="";const[c,g,d]=je(o,t,i,e);n+=d;const r=c>0?o:Qt(o-Math.PI),l=g>0?o:Qt(o-Math.PI),[f,h]=Pt(i,Math.abs(c),t,e),[S,A]=Pt(i,Math.abs(g),t,e);n+=h+A;const u=Math.sign(r)*f,x=Math.sign(l)*S;return[c,r,u,g,l,x,n]}function Pt(o,t,i,e=0){let n="";n+=Et(o,"triLLLrA.l1",e),n+=Et(t,"triLLLrA.l2",e),n+=Et(i,"triLLLrA.l3",e);const c=(i**2+o**2-t**2)/(2*i*o);if(Math.abs(c)>1){const d=`triLLLrA : cosA31 ${St(c)} is bigger than 1`;n+=zt("296",d,e)}return[Math.acos(c),n]}function _o(o,t,i,e=0){let n="";const[c,g]=Pt(o,t,i,e),[d,r]=Pt(t,i,o,e),[l,f]=re(c,d,e);return n+=g+r+f,[c,d,l,n]}var I=(o=>(o[o.eA=0]="eA",o[o.eB=1]="eB",o))(I||{}),H=(o=>(o[o.eABRight=0]="eABRight",o[o.eABLeft=1]="eABLeft",o))(H||{});function Lo(o){let t=0;return o===t&&(t=1),t}var ae=class We extends He{pJuncs=[];lastPosition=-1;facetIdx=-1;ctrIdx=-1;used=0;startJunction(t,i,e){for(const c of this.pJuncs)if(c.jName===t)throw`err209: jName ${t} already used`;const n=this.segments.length-1;if(n===this.lastPosition)throw`err210: jName ${t} overwrites previous position ${n}`;return this.lastPosition=n,this.pJuncs.push({jName:t,jDir:i,jSide:e,jPosition:n}),this}findIdx(t){let i=-1;for(const[e,n]of this.pJuncs.entries())t===n.jName&&(i=e);return i}cloneJ(t){const i=new We(t.segments[0].px,t.segments[0].py);for(const e of t.segments){const n=e.clone();n.sType!==Ae.eStart&&(i.addSeg(n),be(n.sType)&&i.setLastPoint(n.px,n.py))}for(const e of this.pJuncs)i.pJuncs.push({jName:e.jName,jDir:e.jDir,jSide:e.jSide,jPosition:e.jPosition});return i.lastPosition=this.lastPosition,i}generateRevertOrientation(){const t=super.generateRevertOrientation(),i=new We(t.segments[0].px,t.segments[0].py);for(const n of t.segments){const c=n.clone();c.sType!==Ae.eStart&&(i.addSeg(c),be(c.sType)&&i.setLastPoint(c.px,c.py))}const e=this.pJuncs.length;for(let n=0;n<e;n++){const c=this.pJuncs[e-n-1],g=this.segments.length-2-c.jPosition;if(g<0)throw`err110: revert ctrJ len ${this.segments.length} has lastPos ${g} negative`;i.pJuncs.push({jName:c.jName,jDir:Lo(c.jDir),jSide:c.jSide,jPosition:g}),i.lastPosition=g}return i}translate(t,i){const e=super.translate(t,i);return this.cloneJ(e)}translatePolar(t,i){return this.translate(i*Math.cos(t),i*Math.sin(t))}rotate(t,i,e){const n=super.rotate(t,i,e);return this.cloneJ(n)}setIdx(t,i){this.facetIdx=t,this.ctrIdx=i,this.used=0}compareIdx(t,i){let e=!1;return t===this.facetIdx&&i===this.ctrIdx&&(e=!0),e}incrementUsed(){this.used+=1}normOrientation(t){return super.getEnvelop().orientation!==t?this.generateRevertOrientation():this}},$o=class{attached=!1;ax=0;ay=0;aa=0;juncIdx=0;outerInner=[];constructor(o){for(const t of o)this.outerInner.push(t)}place(o){const t=o.getRotation(),[i,e]=o.getTranslation(),n=[];for(const g of this.outerInner)n.push(g.rotate(0,0,t).translate(i,e));const c=Y(n);return c.attached=this.attached,c.ax=this.ax,c.ay=this.ay,c.aa=this.aa,c.juncIdx=this.juncIdx,c}getContourPure(){const o=[];for(const t of this.outerInner)t instanceof ae||o.push(t);return o}getContourJ(o){const t=[];for(const[i,e]of this.outerInner.entries())if(e instanceof ae){const n=e.normOrientation(i===0);n.setIdx(o,i),t.push(n)}return t}getContourAll(){const o=[];for(const t of this.outerInner)o.push(ge(t));return o}};function K(o,t,i=""){return new ae(o,t,i)}function Y(o){return new $o(o)}function ge(o){return o.clone()}var Do=10**-5,vo=class{pThickness=0;pPartName="";pSFMark="";pFacets=[];pJuncs=[];pProfiles=[];constructor(o,t,i,e,n,c){this.pThickness=e,this.pPartName=n,this.pSFMark=c;const g=Object.keys(t);for(const[d,r]of o.entries()){let l=0;for(const[f,h]of r.outerInner.entries())if(h instanceof ae)for(const S of h.pJuncs){const A=S.jName,u=this.pJuncs.map(x=>x.jName);if(u.includes(A)){const x=u.findIndex($=>$===A);if(this.pJuncs[x].associated===1){const $=this.pJuncs[x].a1FacetIdx;if(d<=$)throw`err390: junction ${x} connects facets ${$} and ${d}. Must be higher!`;if(this.pJuncs[x].associated=2,this.pJuncs[x].a2FacetIdx=d,this.pJuncs[x].a2ContIdx=f,this.pJuncs[x].a2SegIdx=S.jPosition,this.pJuncs[x].a2Dir=S.jDir,this.pJuncs[x].a2Side=S.jSide,l===0)l=1;else throw`err628: jName ${A} is the second backward junction of facet-idx ${d}`}else throw`err125: jName ${A} used a third time in facet-idx ${d}`}else if(g.includes(A))this.pJuncs.push({jName:A,angle:t[A].angle,radius:t[A].radius,neutral:t[A].neutral,mark:t[A].mark,associated:1,a1FacetIdx:d,a1ContIdx:f,a1SegIdx:S.jPosition,a1Dir:S.jDir,a1Side:S.jSide,a1x:0,a1y:0,a1Teta:0,a2FacetIdx:-1,a2ContIdx:-1,a2SegIdx:-1,a2Dir:0,a2Side:0,a2x:0,a2y:0,a2Teta:0,jLength:0,jx:0,jy:0});else throw`err129: jName ${A} not defined in junction-list`}if(l===0&&d>0)throw`err738: iFacetIdx ${d} has no backward connection`;this.pFacets.push(r)}this.computeLength(),this.checkFacet();for(const d of i){if(d.l1<=0)throw`err292: profile l1 ${d.l1} is negative or null`;for(const[r,l]of d.ante.entries())if(r%2===0){if(typeof l!="string")throw"err234: even element of ante is not a string";if(!g.includes(l))throw`err242: even element string ${l} of ante is not a declared junctions`}else{if(typeof l!="number")throw"err239: odd element of ante is not a number";if(l<=0)throw`err242: odd element number ${l} of ante is negative or null`}for(const[r,l]of d.post.entries())if(r%2===0){if(typeof l!="string")throw"err234: even element of post is not a string";if(!g.includes(l))throw`err242: even element string ${l} of post is not a declared junctions`}else{if(typeof l!="number")throw"err239: odd element of post is not a number";if(l<=0)throw`err242: odd element number ${l} of post is negative or null`}this.pProfiles.push(d)}}printJuncs(){for(const o of this.pJuncs){const t=o.a1FacetIdx,i=o.a1ContIdx,e=o.a1SegIdx,n=o.a2FacetIdx,c=o.a2ContIdx,g=o.a2SegIdx;console.log(`dbg527: ${o.jName} : ${t} ${i} ${e} : ${n} ${c} ${g}`)}}oneTetaLength(o,t,i){const e=this.pFacets[o].outerInner[t];if(!(e instanceof He))throw`err234: faIdx ${o}, coIdx ${t} is not a Contour but a ContourCircle`;const n=e.segments.length,c=e.segments[i],g=e.segments[(i+1)%n],d=e.segments[(i+2)%n];if(Me(c.sType))throw`err101: junction ${o} ${t} ${i} starts with an active corner`;if(Ae.eStroke!==g.sType)throw`err102: junction ${o} ${t} ${i} is not a stroke`;if(Me(d.sType))throw`err103: junction ${o} ${t} ${i} ends with an active corner`;const r=Math.sqrt((g.px-c.px)**2+(g.py-c.py)**2),l=Math.atan2(g.py-c.py,g.px-c.px),f=`Ax ${a(c.px)} Ay ${a(c.py)} Bx ${a(g.px)} By ${a(g.py)}`;return[c.px,c.py,l,r,f]}computeLength(){for(const[o,t]of this.pJuncs.entries())for(let i=0;i<t.associated;i++){let e=t.a1FacetIdx,n=t.a1ContIdx,c=t.a1SegIdx,g=t.a1Dir;i===1&&(e=t.a2FacetIdx,n=t.a2ContIdx,c=t.a2SegIdx,g=t.a2Dir);const[d,r,l,f,h]=this.oneTetaLength(e,n,c);let S=l,A=d,u=r;if(g===1){const x=xt(d,r).translatePolar(l,f);A=x.cx,u=x.cy,S=Ro(l+Math.PI)}if(i===1){const x=Math.abs(f-t.jLength);if(x>Do){const $=`jName ${t.jName} ${h}`;throw`err908: junction ${o} jLength ${a(t.jLength)} ${a(f)} differs of ${x}
${$}`}if(t.a1Side===t.a2Side)throw`err905: jSide ${t.a1Side} ${t.a2Side} must be opposite`;if(t.a2x=A,t.a2y=u,t.a2Teta=S,this.pFacets[e].attached===!1)this.pFacets[e].attached=!0,this.pFacets[e].ax=A,this.pFacets[e].ay=u,this.pFacets[e].aa=S,this.pFacets[e].juncIdx=o;else throw`err545: pFacet ${e} is already attached`}else t.jLength=f,t.a1Teta=S,t.a1x=A,t.a1y=u}}checkFacet(){for(const[o,t]of this.pFacets.entries())if(o>0&&t.attached===!1)throw`err464: pFacet ${o} ax is not set`}getJuncIdx(o){let t=-1;for(const[i,e]of this.pJuncs.entries())o===e.jName&&(t=i);if(t<0)throw`err801: jName ${o} not found`;return t}fromJunctionToAttach(o){let t=o.a1Teta,i=o.a1x,e=o.a1y;const n=o.a1FacetIdx;if(n>0){const c=this.pFacets[n];t=t-c.aa;const g=i-c.ax,d=e-c.ay,r=Math.sqrt(g**2+d**2),f=Math.atan2(d,g)-c.aa;i=r*Math.cos(f),e=r*Math.sin(f)}return[t,i,e]}positionF(o,t){let i=o;if(t>0){const e=this.pFacets[t].juncIdx,n=this.pJuncs[e];n.a1Side===1?i=i.addRotation(-n.angle,0,0).addTranslation(0,-n.jx,n.jy):i=i.addRotation(n.angle,0,0).addTranslation(0,n.jx,n.jy),i=this.positionJ(i,e)}return i}positionJ(o,t){const i=this.pJuncs[t],[e,n,c]=this.fromJunctionToAttach(i);let g=o.addRotation(0,0,e).addTranslation(n,c,0);const d=i.a1FacetIdx;return d>0&&(g=this.positionF(g,d)),g}positionJ2d(o){const t=Tt();let i=o;if(this.pFacets[o].attached)for(;i>0;){const e=this.pFacets[i].juncIdx,n=this.pJuncs[e],c=Math.abs(n.angle),g=c===0?n.radius:c*n.radius,d=n.a1Side===1?-1:1;t.addTranslation(0,d*g);const[r,l,f]=this.fromJunctionToAttach(n);t.addRotation(r),t.addTranslation(l,f),i=n.a1FacetIdx}else throw`err491: iFacetIdx ${o} is not attached!`;return t}positionF2d(o){const t=this.positionJ2d(o),i=t.getRotation(),[e,n]=t.getTranslation(),c=this.pFacets[o];return Tt().addTranslation(-c.ax,-c.ay).addRotation(-c.aa+i).addTranslation(e,n)}findCtrJ(o,t,i){let e=o[0],n=!1;for(const c of o)c.compareIdx(t,i)&&(e=c,n=!0);if(!n)throw`err612: not found ctrJ with iFacetIdx ${t} and iCtrIdx ${i}`;return e}generateJunc3List(o){const t=[];for(const i of o.pJuncs){const e={jName:i.jName,segPosition:i.jPosition,jDir:i.jDir};t.push(e)}return t}calcJuncList(o,t){const i=o.findIdx(t);if(i<0)throw`err324: junction ${t} not found`;const e=this.generateJunc3List(o);return[...e.slice(i),...e.slice(0,i)]}incrSegIdx(o,t,i){let e=o+t;return e>=i?e=0:e<0&&(e=i+e),e}addSeg(o,t){t.sType!==Ae.eStart&&(o.addSeg(t),o.setLastPoint(t.px,t.py))}makePartialCtr(o,t,i,e){let n=t[0].segPosition,c=this.incrSegIdx(n,0,o.segments.length);i||(n=this.incrSegIdx(t[0].segPosition,1,o.segments.length),c=this.incrSegIdx(n,0,o.segments.length));const g=X(o.segments[n].px,o.segments[n].py);let d=this.incrSegIdx(n,0,o.segments.length);for(let r=1;r<t.length;r++){for(o.incrementUsed();d!==t[r].segPosition;)d=this.incrSegIdx(d,1,o.segments.length),this.addSeg(g,o.segments[d].clone());const l=this.pJuncs[this.getJuncIdx(t[r].jName)];if(l.a2FacetIdx===-1){const f=o.segments[d].px,h=o.segments[d].py;d=this.incrSegIdx(d,1,o.segments.length);const S=o.segments[d].px,A=o.segments[d].py,u=S-f,x=A-h,$=Math.sqrt(u**2+x**2),D=Math.atan2(x,u);let J=0;t[r].jDir===1&&(J=Math.PI);const m=l.angle===0?l.radius:Math.abs(l.angle)*l.radius,_=l.a1Side===1?-Math.PI/2:Math.PI/2;g.addSegStrokeRP(D+_+J,m),g.addSegStrokeRP(D,$),g.addSegStrokeA(S,A)}else{const f=this.findCtrJ(e,l.a2FacetIdx,l.a2ContIdx),h=this.calcJuncList(f,l.jName),S=this.makePartialCtr(f,h,!1,e);g.addSegStrokeA(S.segments[0].px,S.segments[0].py);for(const A of S.segments)this.addSeg(g,A.clone());d=this.incrSegIdx(d,1,o.segments.length),g.addSegStrokeA(o.segments[d].px,o.segments[d].py)}}for(o.incrementUsed(),d=this.incrSegIdx(d,1,o.segments.length);d!==c;)this.addSeg(g,o.segments[d].clone()),d=this.incrSegIdx(d,1,o.segments.length);return g}generateNewContours(o){const t=[];for(const i of o)if(i.used===0){const n=[{jName:"",segPosition:0,jDir:0},...this.generateJunc3List(i)],c=this.makePartialCtr(i,n,!0,o);t.push(c)}return t}generateOneMarker(o){const t=o.angle===0?o.radius:Math.abs(o.angle)*o.radius;return t<2*o.mark?j(-o.mark,0,2*o.mark,t):X(-o.mark,o.mark).addPointA(0,0).addPointA(o.mark,o.mark).addSegArc2().addSegStrokeA(o.mark,t-o.mark).addPointA(0,t).addPointA(-o.mark,t-o.mark).addSegArc2().closeSegStroke()}generateMarkers(){const o=[];for(const t of this.pJuncs){if(t.associated===0)throw`err509: junction ${t.jName} is not associated`;if(t.mark>0){const i=t.a1FacetIdx,e=Math.abs(t.angle),n=e===0?t.radius:e*t.radius,c=t.a1Side===1?-1:0,g=Tt().addTranslation(t.jLength/2,c*n);if(i>0){const[r,l,f]=this.fromJunctionToAttach(t);g.addRotation(r).addTranslation(l,f);const h=this.positionJ2d(i);g.addRotation(h.getRotation()).addTranslation(...h.getTranslation())}else g.addRotation(t.a1Teta).addTranslation(t.a1x,t.a1y);const d=this.generateOneMarker(t).rotate(0,0,g.getRotation()).translate(...g.getTranslation());o.push(d)}}return o}makePatternFigure(o){const t=[];for(const[S,A]of this.pFacets.entries())if(S>0){const u=this.positionF2d(S);t.push(A.place(u))}else{if(A.attached)throw`err490: iFacetIdx ${S} is attached!`;const u=Tt();t.push(A.place(u))}const i=[],e=[],n=[];for(const[S,A]of t.entries())i.push(...A.getContourAll()),e.push(...A.getContourPure()),n.push(...A.getContourJ(S));const c=O();for(const S of i)c.addSecond(S);const g=this.generateNewContours(n),d=this.generateMarkers(),r=[...g,...e,...d],l=[];let f=r[0];const h=So(f.getEnvelop());for(const S of r)h.add(S.getEnvelop())?(l.push(f),f=S):l.push(S);if(o&&!h.check(f.getEnvelop()))throw"err782: the outer-contour does not envelop all contours";return c.addMainOI([f,...l]),c}nameFacePattern(){return`${this.pSFMark}_pattern`}nameFace(o){return`${this.pSFMark}_f${o.toString().padStart(2,"0")}`}nameFaceJ(o){return`${this.pSFMark}_fj${o.toString().padStart(2,"0")}`}nameFaceProfiles(){return`${this.pSFMark}_profiles`}makeFacetFig(o,t){const i=O(),e=[];for(const n of t.outerInner){let c=ge(n);o>0&&(c=c.translate(-t.ax,-t.ay).rotate(0,0,Math.PI/2-t.aa)),e.push(c)}return i.addMainOI(e),i}drawJuncPositive(o,t,i){const e=xt(0,o),n=e.translatePolar(-Math.PI/2+i/2,o),c=e.translatePolar(-Math.PI/2+i,o),g=e.translatePolar(-Math.PI/2+i,t),d=e.translatePolar(-Math.PI/2+i/2,t);return[X(0,0).addPointA(n.cx,n.cy).addPointA(c.cx,c.cy).addSegArc2().addSegStrokeA(g.cx,g.cy).addPointA(d.cx,d.cy).addPointA(0,this.pThickness).addSegArc2().closeSegStroke(),c.cx,c.cy]}drawJuncNegative(o,t,i){const e=xt(0,-t),n=e.translatePolar(Math.PI/2+i/2,o),c=e.translatePolar(Math.PI/2+i,o),g=e.translatePolar(Math.PI/2+i,t),d=e.translatePolar(Math.PI/2+i/2,t);return[X(0,0).addPointA(d.cx,d.cy).addPointA(g.cx,g.cy).addSegArc2().addSegStrokeA(c.cx,c.cy).addPointA(n.cx,n.cy).addPointA(0,this.pThickness).addSegArc2().closeSegStroke(),g.cx,g.cy]}makeJuncCtr(o,t,i,e){let n=j(0,0,i,this.pThickness);if(e<0||e>1)throw`err329: junction ${o} with neutral ${e} not within 0..1`;if(i<0)throw`err328: junction ${o} with negative radius ${i}`;const c=i-this.pThickness*e,g=i+this.pThickness*(1-e);if(c<=0)throw`err901: junction ${o} with negative rI ${c}, radius ${i}, neutral ${e}, thickness ${this.pThickness}`;let d=0,r=0;if(t===0)d=i,r=0;else if(t>0){const[l,f,h]=this.drawJuncPositive(g,c,t);n=l,d=f,r=h}else{const[l,f,h]=this.drawJuncNegative(g,c,t);n=l,d=f,r=h}return[n,d,r]}makeProfileFig(){const o=O();for(const t of this.pProfiles){let i=t.x1,e=t.y1,n=t.a1;o.addMainO(Le(i,e,t.l1,this.pThickness,n));const c=xt(i,e).translatePolar(n,t.l1);i=c.cx,e=c.cy;for(const d of t.post)if(typeof d=="number"){o.addMainO(Le(i,e,d,this.pThickness,n));const r=xt(i,e).translatePolar(n,d);i=r.cx,e=r.cy}else{const r=this.pJuncs[this.getJuncIdx(d)],[l,f,h]=this.makeJuncCtr(r.jName,r.angle,r.radius,r.neutral);o.addMainO(l.rotate(0,0,n).translate(i,e));const S=xt(f,h).rotate(xt(0,0),n);i+=S.cx,e+=S.cy,n+=r.angle}i=t.x1,e=t.y1,n=t.a1+Math.PI;const g=xt(i,e).translatePolar(n-Math.PI/2,this.pThickness);i=g.cx,e=g.cy;for(const d of t.ante)if(typeof d=="number"){o.addMainO(Le(i,e,d,this.pThickness,n));const r=xt(i,e).translatePolar(n,d);i=r.cx,e=r.cy}else{const r=this.pJuncs[this.getJuncIdx(d)],[l,f,h]=this.makeJuncCtr(r.jName,-r.angle,r.radius,r.neutral);o.addMainO(l.rotate(0,0,n).translate(i,e));const S=xt(f,h).rotate(xt(0,0),n);i+=S.cx,e+=S.cy,n-=r.angle}}return o}makeFigures(o=!0){const t={};if(this.pThickness<=0)throw`err822: thickness ${this.pThickness} is negative`;if(t[this.nameFacePattern()]=this.makePatternFigure(o),this.pProfiles.length>0){const i=this.nameFaceProfiles();t[i]=this.makeProfileFig()}for(const[i,e]of this.pFacets.entries()){const n=this.nameFace(i);t[n]=this.makeFacetFig(i,e)}for(const[i,e]of this.pJuncs.entries()){const n=this.nameFaceJ(i),[c,g,d]=this.makeJuncCtr(e.jName,e.angle,e.radius,e.neutral),r=O();r.addMainO(c),t[n]=r,e.jx=g,e.jy=d}return t}makeVolume(){const o=[];for(const n of this.pFacets.keys()){const c=Dt();let g=c;if(n>0){const r=c.addRotation(0,0,-Math.PI/2);g=this.positionF(r,n)}const d={outName:`subpax_${this.pPartName}_${this.nameFace(n)}`,face:`${this.pPartName}_${this.nameFace(n)}`,extrudeMethod:et.eLinearOrtho,length:this.pThickness,rotate:g.getRotation(),translate:g.getTranslation()};o.push(d)}for(const[n,c]of this.pJuncs.entries()){let g=Dt();c.a1Side===1?g=g.addRotation(Math.PI/2,0,0).addTranslation(0,c.jLength,0).addRotation(0,0,-Math.PI/2):g=g.addRotation(Math.PI/2,0,0).addRotation(0,0,Math.PI/2);const d=this.positionJ(g,n),r={outName:`subpax_${this.pPartName}_${this.nameFaceJ(n)}`,face:`${this.pPartName}_${this.nameFaceJ(n)}`,extrudeMethod:et.eLinearOrtho,length:c.jLength,rotate:d.getRotation(),translate:d.getTranslation()};o.push(r)}const t=o.map(n=>n.outName),i=[],e={outName:`pax_${this.pPartName}`,boolMethod:Rt.eUnion,inList:t};return i.push(e),{extrudes:o,volumes:i}}};function qt(o,t,i,e,n,c="SFG"){return new vo(o,t,i,e,n,c)}function ce(o){const t=O(),i=[];for(const e of o.outerInner)e instanceof ae?i.push(ge(e)):i.push(e);return t.addMainOI(i),t}var Oe={partName:"door",params:[s("L1","mm",1200,400,4e3,10),s("L2","mm",200,50,500,10),s("W1","mm",1e3,50,5e3,10),z("Heights"),s("H1","mm",500,100,4e3,10),s("H2","mm",1600,100,4e3,10),s("H3","mm",200,10,500,10),z("Details"),s("R1","mm",200,50,500,10),s("R2","mm",1e3,50,5e3,10)],paramSvg:{H1:"door_face.svg",H2:"door_face.svg",H3:"door_face.svg",L1:"door_face.svg",L2:"door_face.svg",R1:"door_face.svg",R2:"door_face.svg",W1:"door_face.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function kt(o,t,i,e,n){const c=o+t*n,g=e+i*Math.cosh(n);return xt(c,g,Ao.eTri1)}function fe(o,t,i){const e=t*Math.sinh(i)/o;return Math.atan2(e,1)}function mo(o,t,i=""){const e=ft(Oe.partName+i),n=O(),c=O(),g=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const d=t.L1+2*t.L2,r=d/2,l=t.H1+t.H2,f=t.H2+t.H3,h=t.H1+f,S=t.L1/2,A=d/2,u=-t.H2/(Math.cosh(1)-Math.cosh(0)),x=-f/(Math.cosh(1)-Math.cosh(0)),$=t.H1-u*Math.cosh(1),D=t.H1-x*Math.cosh(1);e.logstr+=`door: height-int ${a(l/1e3)}  height-ext ${a(h/1e3)}  width-ext ${a(d/1e3)} m
`,e.logstr+=`internal cosh a1 ${a(S)}  b1 ${a(u)}  c1 ${a($)}
`,e.logstr+=`external cosh a2 ${a(A)}  b2 ${a(x)}  c2 ${a(D)}
`;const J=10;for(let V=0;V<J;V++)n.addPoint(kt(r,S,u,$,-1+V/J)),n.addPoint(kt(r,A,x,D,-1+V/J));const m=kt(r,S,u,$,-1),_=kt(r,S,u,$,-.5),M=kt(r,S,u,$,0),B=kt(r,S,u,$,.5),v=kt(r,S,u,$,1),C=kt(r,A,x,D,-1),y=kt(r,A,x,D,-.5),E=kt(r,A,x,D,0),k=kt(r,A,x,D,.5),N=kt(r,A,x,D,1);n.addPoint(m),n.addPoint(_),n.addPoint(M),n.addPoint(B),n.addPoint(v),n.addPoint(C),n.addPoint(y),n.addPoint(E),n.addPoint(k),n.addPoint(N);const T=fe(S,u,-1),w=fe(S,u,-.5),L=fe(A,x,-1),F=fe(A,x,-.5);n.addVector(ie(T,t.L2,m)),n.addVector(ie(w,t.L2,_)),n.addVector(ie(L,t.L2,C)),n.addVector(ie(F,t.L2,y));const P=X(0,0).addSegStrokeA(t.L2,0).addSegStrokeA(t.L2,t.H1).addCornerRounded(t.R1).addPointA(_.cx,_.cy).addSeg2Arcs(T,Math.PI+w).addPointA(r,l).addSeg2Arcs(w,Math.PI).addPointA(B.cx,B.cy).addSeg2Arcs(0,Math.PI-w).addPointA(t.L2+t.L1,t.H1).addSeg2Arcs(-w,Math.PI-T).addCornerRounded(t.R1).addSegStrokeA(t.L2+t.L1,0).addSegStrokeA(2*t.L2+t.L1,0).addSegStrokeA(2*t.L2+t.L1,t.H1).addCornerRounded(t.R2).addPointA(k.cx,k.cy).addSeg2Arcs(Math.PI-L,-F).addPointA(r,h).addSeg2Arcs(Math.PI-F,0).addPointA(y.cx,y.cy).addSeg2Arcs(Math.PI,F).addPointA(0,t.H1).addSeg2Arcs(Math.PI+F,L).addCornerRounded(t.R2).closeSegStroke();n.addMainO(P),c.addMainO(j(-t.L2-t.L1/2,0,t.L2,t.W1)),c.addMainO(j(t.L1/2,0,t.L2,t.W1)),c.addSecond(j(-t.L1/2,0,t.L1,t.W1)),g.addMainO(j(0,0,t.W1,t.H1+t.H2+t.H3)),g.addSecond(j(0,0,t.W1,t.H1+t.H2)),e.fig={faceDoor:n,faceTop:c,faceSide:g};const q=e.partName;e.vol={extrudes:[{outName:`subpax_${q}`,face:`${q}_faceDoor`,extrudeMethod:et.eLinearOrtho,length:t.W1,rotate:[0,0,0],translate:[0,0,0]}],volumes:[{outName:`pax_${q}`,boolMethod:Rt.eIdentity,inList:[`subpax_${q}`]}]},e.sub={},e.logstr+=`door drawn successfully!
`,e.calcErr=!1}catch(d){e.logstr+=d,console.log(d)}return e}var ko={pTitle:"Door",pDescription:"A door with hyperbolic arc",pDef:Oe,pGeom:mo},Ge={partName:"maison",params:[s("H1","m",12,3,50,.1),s("H2","m",6,2,50,.1),s("H3","m",6,2,50,.1),s("RS","%",50,10,90,1),z("TopView"),s("A1","degree",135,90,180,1),s("W1","m",12,2,50,.1),s("W2","m",12,2,50,.1),s("L1","m",16,2,50,.1),s("L2","m",16,2,50,.1),z("Roof border"),s("WF1","m",.4,0,1.5,.1),s("WBL","%",3,0,20,.01),s("WBH","%",5,0,20,.01),s("AB1","degree",15,0,80,1),s("WBE","m",.3,.05,1,.01),s("WBR","%",50,0,100,1),z("Chimney"),ht("ChiNb",["5","4","3","2","1","0"]),s("ChiOffset","m",1.5,0,5,.1),s("ChiH","m",1.5,0,3,.1),s("ChiW","m",1.5,.3,3,.1),s("ChiT","m",.6,.3,3,.1)],paramSvg:{H1:"maison_side.svg",H2:"maison_side.svg",H3:"maison_side.svg",RS:"maison_side.svg",A1:"maison_top.svg",W1:"maison_top.svg",W2:"maison_top.svg",L1:"maison_top.svg",L2:"maison_top.svg",WF1:"maison_roofBorder.svg",WBL:"maison_roofBorder.svg",WBH:"maison_roofBorder.svg",AB1:"maison_roofBorder.svg",WBE:"maison_roofBorder.svg",WBR:"maison_roofBorder.svg",ChiNb:"maison_chimney_nb.svg",ChiOffset:"maison_chimney_nb.svg",ChiH:"maison_chimney.svg",ChiW:"maison_chimney.svg",ChiT:"maison_chimney.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function Wo(o,t,i=""){const e=ft(Ge.partName+i),n=O(),c=O(),g=O(),d=O(),r=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{let h=function(at,Z,It,Lt,Xt){const At=X(0,0).addSegStrokeA(at,0).addSegStrokeA(at,t.H2).addSegStrokeA(at+Z,t.H2);return b?At.addSegStrokeA(at+Z,t.H2+t.WBE):At.addPointA(at+Z+U,t.H2+t.WBE/2).addPointA(at+Z,t.H2+t.WBE).addSegArc2(),At.addSegStrokeA(at+Z-It,t.H2+t.WBE+lt).addSegStrokeA(Lt+Xt/2,t.H1).addSegStrokeA(Lt-Xt/2,t.H1).addSegStrokeA(-Z+It,t.H3+t.WBE+lt).addSegStrokeA(-Z,t.H3+t.WBE),b?At.addSegStrokeA(-Z,t.H3):At.addPointA(-Z-U,t.H3+t.WBE/2).addPointA(-Z,t.H3).addSegArc2(),At.addSegStrokeA(0,t.H3).closeSegStroke(),At},S=function(at,Z,It,Lt,Xt,At,Ht){return X(0,Ht).addSegStrokeA(0,At).addSegStrokeA(-Z,At).addSegStrokeA(-Z,Ht).addSegStrokeA(-Z+It,Ht).addSegStrokeA(-Z+It,At).addSegStrokeA(Lt-Xt/2,At).addSegStrokeA(Lt-Xt/2,Ht).addSegStrokeA(Lt,Ht).addSegStrokeA(Lt,At).addSegStrokeA(Lt+Xt/2,At).addSegStrokeA(Lt+Xt/2,Ht).addSegStrokeA(at+Z-It,Ht).addSegStrokeA(at+Z-It,At).addSegStrokeA(at+Z,At).addSegStrokeA(at+Z,Ht).addSegStrokeA(at,Ht).addSegStrokeA(at,At)};var l=h,f=S;const A=t.W1*t.RS/100,u=t.W2*t.RS/100,x=p(t.A1),$=Math.PI-x,[D,J]=Yt(t.W1,$,t.W2),[m,_]=Pt(D,t.W1,t.W2),[M,B]=Pt(t.W1,t.W2,D),v=Math.PI/2-M,C=Math.PI/2-m;if(v<0)throw`err785: aEBC ${a(Q($))} degree is negative`;if(C<0)throw`err786: aDEC ${a(Q(C))} degree is negative`;const[y,E,k]=Ve(v,D,C),N=Math.atan2(E,t.W1),T=Math.atan2(y,t.W2),w=Math.sqrt(t.W1**2+E**2),L=t.L1+E,F=t.L2+y,P=x-Math.PI,q=t.W1*t.WBL/100,V=t.W1*t.WBH/100,R=t.W2*t.WBL/100,W=t.W2*t.WBH/100,b=t.WBR<1,U=t.WBE*t.WBR/200,it=p(t.AB1),lt=V*Math.tan(it),tt=t.W2/t.W1,ot=t.WF1*tt,rt=q+t.WBE*2,gt=R+t.WBE*tt*2,st=rt*Math.tan(N),_t=t.L1-st,nt=L+st,Wt=gt*Math.tan(T),Nt=F+Wt,Gt=Math.min(t.H2,t.H3),ct=t.H1+t.ChiH-Gt,ut=5-t.ChiNb;if(t.H1<t.H2||t.H1<t.H3)throw`err885: H1 ${a(t.H1)} is too small compare to H2 ${a(t.H2)} or H3 ${a(t.H3)}`;const pt=v+C+x;if(Math.abs(pt-Math.PI)>.001)throw`err786: sum of aDEC, aDEC and aA1 is not 1880 degree: ${a(Q(C))}, aDEC ${a(Q(C))}, aA1 ${a(Q(x))}, sum ${a(Q(pt))}`;e.logstr+=`maison: height ${a(t.H1)} m
`,e.logstr+=`maison: aA3: ${a(Q(N))}, aA2: ${a(Q(T))} degree
`,e.logstr+=`fold lBD: ${a(w)} m
`,e.logstr+=`Roof border: low-1: ${a(q)} low-2: ${a(R)} high-1: ${a(V)} high-2: ${a(W)}
`,e.logstr+=`Roof top: WF1: ${a(t.WF1)} WF2: ${a(ot)} m  ratio12: ${a(tt)}
`,e.logstr+=`triangule: ${J}${_}${B}${k}
`;const te=h(t.W1,q,V,A,t.WF1),ee=h(t.W2,R,W,u,ot),Ut=j(A-t.ChiW/2,Gt,t.ChiW,ct);n.addMainO(te),n.addSecond(ee.translate(A-u,0)),ut>0&&n.addSecond(Ut),c.addMainO(ee),c.addSecond(te.translate(u-A,0)),ut>0&&c.addSecond(Ut);const wt=X(-rt,0).addSegStrokeA(t.W1+rt,0).addSegStrokeA(t.W1+rt,_t).addSegStrokeA(-rt,nt).closeSegStroke(),Ft=X(0,0).addSegStrokeA(t.W1,0).addSegStrokeA(t.W1,t.L1).addSegStrokeA(0,L).closeSegStroke(),$t=S(t.W1,q,V,A,t.WF1,0,L),Bt=X(-gt,-Wt).addSegStrokeA(t.W2+gt,y+Wt).addSegStrokeA(t.W2+gt,F).addSegStrokeA(-gt,F).closeSegStroke(),mt=X(0,0).addSegStrokeA(t.W2,y).addSegStrokeA(t.W2,F).addSegStrokeA(0,F).closeSegStroke(),yt=S(t.W2,R,W,u,ot,0,F);g.addMainO(wt),g.addDynamics(Ft),g.addSecond($t),g.addSecond(Bt.translate(0,L).rotate(0,L,P)),g.addDynamics(mt.translate(0,L).rotate(0,L,P)),g.addSecond(yt.translate(0,L).rotate(0,L,P)),d.addMainO(Bt),d.addDynamics(mt),d.addSecond(yt),d.addSecond(wt.translate(0,-L).rotate(0,0,-P)),d.addDynamics(Ft.translate(0,-L).rotate(0,0,-P)),d.addSecond($t.translate(0,-L).rotate(0,0,-P));const Jt=[j(A-t.ChiW/2,t.ChiOffset,t.ChiW,t.ChiT)];ut>1&&Jt.push(j(u-t.ChiW/2,F-t.ChiOffset-t.ChiT,t.ChiW,t.ChiT).translate(0,L).rotate(0,L,P)),ut>2&&Jt.push(j(A-t.ChiW/2,t.L1+(E-t.ChiT)/2,t.ChiW,t.ChiT).rotate(A,t.L1+E/2,-N)),ut>3&&Jt.push(j(A-t.ChiW/2,(L+t.ChiOffset-t.ChiT)/2,t.ChiW,t.ChiT)),ut>4&&Jt.push(j(u-t.ChiW/2,(F-t.ChiOffset-t.ChiT)/2,t.ChiW,t.ChiT).translate(0,L).rotate(0,L,P));for(const at of Jt)r.addMainO(at);if(r.addSecond(Ft),r.addDynamics(Ft),r.addSecond($t),r.addSecond(mt.translate(0,L).rotate(0,L,P)),r.addDynamics(mt.translate(0,L).rotate(0,L,P)),r.addSecond(yt.translate(0,L).rotate(0,L,P)),ut>0)for(const at of Jt)g.addSecond(at),d.addSecond(at.translate(0,-L).rotate(0,0,-P));e.fig={faceSide1:n,faceSide2:c,faceTop1:g,faceTop2:d,faceChimney:r};const dt=e.partName,oe=Dt().addRotation(0,0,P).addTranslation(0,L,0),ne=Dt().addRotation(Math.PI/2,0,0).addTranslation(0,F,0).addRotation(0,0,P).addTranslation(0,L,0),de=[`ipax_${dt}_1`,`ipax_${dt}_2`];ut>0&&de.push(`subpax_${dt}_chi1`),e.vol={extrudes:[{outName:`subpax_${dt}_top1`,face:`${dt}_faceTop1`,extrudeMethod:et.eLinearOrtho,length:t.H1,rotate:[0,0,0],translate:[0,0,0]},{outName:`subpax_${dt}_side1`,face:`${dt}_faceSide1`,extrudeMethod:et.eLinearOrtho,length:nt,rotate:[Math.PI/2,0,0],translate:[0,nt,0]},{outName:`subpax_${dt}_top2`,face:`${dt}_faceTop2`,extrudeMethod:et.eLinearOrtho,length:t.H1,rotate:oe.getRotation(),translate:oe.getTranslation()},{outName:`subpax_${dt}_side2`,face:`${dt}_faceSide2`,extrudeMethod:et.eLinearOrtho,length:Nt,rotate:ne.getRotation(),translate:ne.getTranslation()},{outName:`subpax_${dt}_chi1`,face:`${dt}_faceChimney`,extrudeMethod:et.eLinearOrtho,length:ct,rotate:[0,0,0],translate:[0,0,Gt]}],volumes:[{outName:`ipax_${dt}_1`,boolMethod:Rt.eIntersection,inList:[`subpax_${dt}_top1`,`subpax_${dt}_side1`]},{outName:`ipax_${dt}_2`,boolMethod:Rt.eIntersection,inList:[`subpax_${dt}_top2`,`subpax_${dt}_side2`]},{outName:`pax_${dt}`,boolMethod:Rt.eUnion,inList:de}]},e.sub={},e.logstr+=`maison drawn successfully!
`,e.calcErr=!1}catch(h){e.logstr+=h,console.log(h)}return e}var yo={pTitle:"Maison",pDescription:"An house with a fold",pDef:Ge,pGeom:Wo},ze={partName:"cabane_plancher",params:[s("N1","planches",8,2,100,1),s("N2","planches",13,2,100,1),s("W1","mm",200,20,800,1),s("W2","mm",200,20,800,1),z("Pilotis face"),s("H1","mm",400,10,2e3,10),s("H2","mm",150,10,400,1),s("H3","mm",150,10,400,1),s("W3","mm",150,10,400,1),s("a1","degree",80,20,90,1),s("W4","mm",150,10,400,1),s("W5","mm",135,10,400,1),s("E1","mm",200,0,1e3,10),z("Pilotis side"),s("T1","mm",20,1,300,1),s("ES1","mm",.2,0,2,.1),s("ES2","mm",.2,0,2,.1),s("S1","mm",200,0,1e3,10),s("S2","mm",100,10,400,10)],paramSvg:{N1:"cabane_plancher_top.svg",N2:"cabane_plancher_bottom.svg",W1:"cabane_plancher_top.svg",W2:"cabane_plancher_bottom.svg",H1:"cabane_plancher_face.svg",H2:"cabane_plancher_face.svg",H3:"cabane_plancher_face.svg",W3:"cabane_plancher_face.svg",a1:"cabane_plancher_face.svg",W4:"cabane_plancher_face.svg",W5:"cabane_plancher_face.svg",E1:"cabane_plancher_face.svg",T1:"cabane_plancher_face.svg",ES1:"cabane_plancher_top.svg",ES2:"cabane_plancher_bottom.svg",S1:"cabane_plancher_side.svg",S2:"cabane_plancher_side.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function Jo(o,t,i=""){const e=ft(ze.partName+i),n=O(),c=O(),g=O(),d=O(),r=O(),l=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const f=t.N1*t.W1+(t.N1-1)*t.ES1,h=t.N2*t.W2+(t.N2-1)*t.ES2,S=1.618,A=h/f,u=f/2,x=p(t.a1),$=t.W4-t.W5,D=$*Math.tan(x),J=t.H3/Math.tan(x),m=t.W3/Math.cos(Math.PI/2-x),_=t.W3*Math.tan(Math.PI/2-x),M=t.H1/Math.tan(x),B=u-t.E1-t.W5-J-m,v=t.H2/Math.tan(x);if($<0)throw`err108: W5 ${t.W5} is too large compare to W4 ${t.W4}`;if(D>t.H3)throw`err111: H3 ${t.H3} is too small compare to a1 ${t.a1} or W5b ${$}`;if(B<0)throw`err119: N1 ${t.N1} or W1 ${t.W1} are too small compare to E1 ${t.E1}, W5 ${t.W5}, H3 ${t.H3} or W3 ${t.W3}`;e.logstr+=`cabane-plancher-size: A: ${a(f)} mm, B: ${a(h)} mm, surface: ${a(f*h*10**-6)} m2
`,e.logstr+=`Comparison with the golden-ratio: B/A: ${a(A)}   ${a(100*A/S)} %
`,e.logstr+=`beam-bevel: W5b: ${a($)} mm, H3b: ${a(D)} mm
`,e.logstr+=`buttress-length: ${a(2*(B+v))} mm
`,e.logstr+=`leg-length: ${a(t.H1/Math.sin(x)+_)} mm
`;for(let L=0;L<t.N1;L++)n.addMainO(j(0,L*(t.W1+t.ES1),h,t.W1));for(let L=0;L<t.N2;L++)n.addSecond(j(L*(t.W2+t.ES2),0,t.W2,f));for(let L=0;L<t.N1;L++)c.addSecond(j(0,L*(t.W1+t.ES1),h,t.W1));for(let L=0;L<t.N2;L++)c.addMainO(j(L*(t.W2+t.ES2),0,t.W2,f));for(let L=0;L<t.N1;L++)g.addSecond(j(L*(t.W1+t.ES1),t.H1+t.T1,t.W1,t.T1));g.addSecond(j(0,t.H1,f,t.T1)),d.mergeFigure(g),r.mergeFigure(g);const C=function(L){return X(u+L*(u-t.E1),t.H1).addSegStrokeR(-L*t.W4,0).addSegStrokeR(0,-t.H3+D).addSegStrokeR(L*$,-D).addSegStrokeR(L*t.W5,0).closeSegStroke()};g.addMainO(C(-1)),g.addMainO(C(1));const y=function(L){return X(u+L*B,t.H1).addSegStrokeR(L*m,0).addSegStrokeR(L*M,-t.H1).addSegStrokeR(-L*m,0).closeSegStroke()};g.addSecond(y(-1)),g.addSecond(y(1));const E=X(u-B,t.H1).addSegStrokeR(2*B,0).addSegStrokeR(v,-t.H2).addSegStrokeR(-2*(B+v),0).closeSegStroke();g.addSecond(E),d.addSecond(C(-1)),d.addSecond(C(1)),d.addMainO(y(-1)),d.addMainO(y(1)),d.addSecond(E),r.addSecond(C(-1)),r.addSecond(C(1)),r.addSecond(y(-1)),r.addSecond(y(1)),r.addMainO(E),l.addSecond(j(0,t.H1+t.T1,h,t.T1));for(let L=0;L<t.N2;L++)l.addSecond(j(L*(t.W2+t.ES2),t.H1,t.W2,t.T1));l.addSecond(j(0,t.H1-t.H3,h,t.H2)),l.addMainO(j(t.S1,0,t.S2,t.H1)),l.addMainO(j(h-t.S1-t.S2,0,t.S2,t.H1)),e.fig={facePlancherTop:n,facePlancherBottom:c,faceBeam:g,faceLeg:d,faceButtress:r,faceSide:l};const k=e.partName,N=Dt();N.addRotation(Math.PI/2,0,0),N.addTranslation(0,h,0),N.addRotation(0,0,-Math.PI/2),N.addTranslation(0,f,0);const T=Dt();T.addRotation(Math.PI/2,0,0),T.addTranslation(0,t.S2+t.S1,0),T.addRotation(0,0,-Math.PI/2),T.addTranslation(0,f,0);const w=Dt();w.addRotation(Math.PI/2,0,0),w.addTranslation(0,h-t.S1,0),w.addRotation(0,0,-Math.PI/2),w.addTranslation(0,f,0),e.vol={extrudes:[{outName:`subpax_${k}_plancherTop`,face:`${k}_facePlancherTop`,extrudeMethod:et.eLinearOrtho,length:t.T1,rotate:[0,0,0],translate:[0,0,t.H1+t.T1]},{outName:`subpax_${k}_plancherBottom`,face:`${k}_facePlancherBottom`,extrudeMethod:et.eLinearOrtho,length:t.T1,rotate:[0,0,0],translate:[0,0,t.H1]},{outName:`subpax_${k}_beam`,face:`${k}_faceBeam`,extrudeMethod:et.eLinearOrtho,length:h,rotate:N.getRotation(),translate:N.getTranslation()},{outName:`subpax_${k}_leg1`,face:`${k}_faceLeg`,extrudeMethod:et.eLinearOrtho,length:t.S2,rotate:T.getRotation(),translate:T.getTranslation()},{outName:`subpax_${k}_leg2`,face:`${k}_faceLeg`,extrudeMethod:et.eLinearOrtho,length:t.S2,rotate:w.getRotation(),translate:w.getTranslation()},{outName:`subpax_${k}_buttress1`,face:`${k}_faceButtress`,extrudeMethod:et.eLinearOrtho,length:t.S2,rotate:T.getRotation(),translate:T.getTranslation()},{outName:`subpax_${k}_buttress2`,face:`${k}_faceButtress`,extrudeMethod:et.eLinearOrtho,length:t.S2,rotate:w.getRotation(),translate:w.getTranslation()}],volumes:[{outName:`pax_${k}`,boolMethod:Rt.eUnion,inList:[`subpax_${k}_plancherTop`,`subpax_${k}_plancherBottom`,`subpax_${k}_beam`,`subpax_${k}_leg1`,`subpax_${k}_leg2`,`subpax_${k}_buttress1`,`subpax_${k}_buttress2`]}]},e.sub={},e.logstr+=`cabane_plancher drawn successfully!
`,e.calcErr=!1}catch(f){e.logstr+=f,console.log(f)}return e}var ye={pTitle:"Plancher de Cabane",pDescription:"Le plancher de la cabane des enfants",pDef:ze,pGeom:Jo},qe={partName:"cabane",params:[s("W1","mm",1600,100,4e3,1),s("W2","mm",2600,100,4e3,1),s("H1","mm",400,10,2e3,10),s("T1","mm",20,1,300,1),z("Face"),s("RCz","mm",2e3,100,4e3,1),s("RCx","mm",0,-2e3,2e3,1),s("RLz","mm",1200,100,4e3,1),s("RLx","mm",400,100,2e3,1),s("RLe","mm",200,0,2e3,1),s("RRz","mm",900,100,4e3,1),s("RRx","mm",200,100,2e3,1),s("RRe","mm",100,0,2e3,1),z("Roof top"),s("RCyf","mm",500,0,2e3,1),s("RCyb","mm",300,0,2e3,1),s("RLyf","mm",400,0,2e3,1),s("RLyb","mm",200,0,2e3,1),s("RRyf","mm",300,0,2e3,1),s("RRyb","mm",100,0,2e3,1),s("RoR","mm",300,0,500,1),z("Door"),s("DPL","mm",-100,-2e3,2e3,1),s("DW","mm",600,100,3e3,1),s("DLz","mm",900,100,4e3,1),s("DLx","mm",200,100,1e3,1),s("DCz","mm",1500,100,4e3,1),s("DCx","mm",300,100,1e3,1),s("DRz","mm",700,100,4e3,1),s("DRx","mm",200,100,1e3,1),s("DR","mm",200,0,500,1),z("Window"),s("Fz1","mm",700,0,3e3,1),s("Fz2","mm",700,10,3e3,1),s("FSx","mm",100,-1e3,1e3,1),s("FWL","mm",500,10,1e3,1),s("FWH","mm",700,10,1e3,1),s("FPLx","mm",-700,-3e3,3e3,1),s("FR","mm",100,0,500,1)],paramSvg:{W1:"cabane_face.svg",W2:"cabane_side.svg",H1:"cabane_face.svg",T1:"cabane_face.svg",RCz:"cabane_face.svg",RCx:"cabane_face.svg",RLz:"cabane_face.svg",RLx:"cabane_face.svg",RLe:"cabane_face.svg",RRz:"cabane_face.svg",RRx:"cabane_face.svg",RRe:"cabane_face.svg",RCyf:"cabane_side.svg",RCyb:"cabane_side.svg",RLyf:"cabane_side.svg",RLyb:"cabane_side.svg",RRyf:"cabane_side.svg",RRyb:"cabane_side.svg",RoR:"cabane_side.svg",DPL:"cabane_face.svg",DW:"cabane_face.svg",DLz:"cabane_face.svg",DLx:"cabane_face.svg",DCz:"cabane_face.svg",DCx:"cabane_face.svg",DRz:"cabane_face.svg",DRx:"cabane_face.svg",DR:"cabane_face.svg",Fz1:"cabane_face.svg",Fz2:"cabane_face.svg",FSx:"cabane_face.svg",FWL:"cabane_face.svg",FWH:"cabane_face.svg",FPLx:"cabane_face.svg",FR:"cabane_face.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function To(o,t,i=""){const e=ft(qe.partName+i),n=O(),c=O(),g=O(),d=O(),r=O(),l=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const A=(t.W1-1.4000000000000001)/8,u=(t.W2-12*.2)/13,x=8*A+7*.2,$=13*u+12*.2,D=1.618,J=$/x,m=t.W1/20,_=t.H1+2*t.T1,M=t.W1/2+t.DPL,B=Math.atan2(t.RCz-t.RLz,t.W1/2+t.RCx+t.RLx),v=Math.atan2(t.RCz-t.RRz,t.W1/2-t.RCx+t.RRx),C=t.T1*Math.cos(B-Math.PI/2),y=-t.T1*Math.sin(B-Math.PI/2),E=t.T1*Math.cos(v-Math.PI/2),k=-t.T1*Math.sin(v-Math.PI/2),N=t.T1/Math.sin(Math.PI/2-B),T=t.T1/Math.sin(Math.PI/2-v),L=(t.RLe-C)*Math.tan(B),P=(t.RRe-E)*Math.tan(v),q=-t.RLx+t.RLe,V=_+t.RLz-y+L,R=t.W1+t.RRx-t.RRe,W=_+t.RRz-k+P,b=Math.atan2(V-_,-q),U=Math.atan2(W-_,R-t.W1),it=t.T1/Math.sin(b),lt=t.T1/Math.sin(U),tt=t.T1/Math.cos(B-Math.PI/2+b),ot=t.T1/Math.cos(v-Math.PI/2+U),rt=tt*Math.cos(B),gt=tt*Math.sin(B),st=ot*Math.cos(v),_t=ot*Math.sin(v),nt=t.W1/2+t.FPLx,Wt=Math.max(t.RCyb,t.RRyb,t.RLyb),Nt=Math.max(t.RCyf,t.RRyf,t.RLyf),Gt=Wt+Nt+t.W2;e.logstr+=`cabane-plancher-size: A: ${a(x)} m, B: ${a($)} m, surface: ${a(x*$)} m2
`,e.logstr+=`Comparison with the golden-ratio: B/A: ${a(J)}   ${a(100*J/D)} %
`,e.logstr+=`roof angles: left: ${a(Q(B))} degree, right: ${a(Q(v))} degree
`,e.logstr+=`side-wall angles: left: ${a(Q(b))} degree, right: ${a(Q(U))} degree
`,e.logstr+=`roof: length-max: ${a(Gt)} mm, back-max: ${a(Wt)} mm, front-max: ${a(Nt)} mm
`;const ct=bt(ye.pDef,"");ct.setVal("N1",8),ct.setVal("W1",A),ct.setVal("N2",13),ct.setVal("W2",u),ct.setVal("H1",t.H1),ct.setVal("H2",m),ct.setVal("H3",m),ct.setVal("W3",m),ct.setVal("a1",80),ct.setVal("W4",m),ct.setVal("W5",m-1),ct.setVal("E1",m),ct.setVal("T1",t.T1),ct.setVal("ES1",.2),ct.setVal("ES2",.2),ct.setVal("S1",2*m),ct.setVal("S2",m);const ut=ye.pGeom(0,ct.getParamVal(),ct.getSuffix());vt(ut),e.logstr+=Mt(ut.logstr,ct.getPartNameSuffix()),n.mergeFigure(ut.fig.facePlancherTop,!0);const pt=X(-t.RLyb,-t.RLx).addCornerRounded(t.RoR).addSegStrokeA(t.W2+t.RLyf,-t.RLx).addCornerRounded(t.RoR).addSegStrokeA(t.W2+t.RCyf,t.W1/2+t.RCx).addCornerRounded(t.RoR).addSegStrokeA(t.W2+t.RRyf,t.W1+t.RRx).addCornerRounded(t.RoR).addSegStrokeA(-t.RRyb,t.W1+t.RRx).addCornerRounded(t.RoR).addSegStrokeA(-t.RCyb,t.W1/2+t.RCx).addCornerRounded(t.RoR).closeSegStroke();n.addMainO(pt);const te=j(0,-t.RLx+t.RLe,t.W2,t.W1+t.RLx+t.RRx-t.RLe-t.RRe),ee=j(t.T1,-t.RLx+t.RLe+t.T1,t.W2-2*t.T1,t.W1+t.RLx+t.RRx-t.RLe-t.RRe-2*t.T1);n.addSecond(te),n.addSecond(ee),c.mergeFigure(ut.fig.faceBeam,!0);const Ut=function(It){const Lt=X(0,_);return It&&Lt.addSegStrokeA(M,_).addSegStrokeA(M-t.DLx,_+t.DLz).addCornerRounded(t.DR).addSegStrokeA(M+t.DCx,_+t.DCz).addCornerRounded(t.DR).addSegStrokeA(M+t.DW+t.DRx,_+t.DRz).addCornerRounded(t.DR).addSegStrokeA(M+t.DW,_),Lt.addSegStrokeA(t.W1,_).addSegStrokeA(R,W).addSegStrokeA(t.W1/2+t.RCx,_+t.RCz-T),N!==T&&Lt.addSegStrokeA(t.W1/2+t.RCx,_+t.RCz-N),Lt.addSegStrokeA(q,V).closeSegStroke(),Lt},wt=Ut(!0),Ft=Ut(!1),$t=X(t.W1/2+t.RCx,_+t.RCz).addSegStrokeA(-t.RLx,_+t.RLz).addSegStrokeA(-t.RLx+C,_+t.RLz-y).addSegStrokeA(t.W1/2+t.RCx,_+t.RCz-N);N!==T&&$t.addSegStrokeA(t.W1/2+t.RCx,_+t.RCz-T),$t.addSegStrokeA(t.W1+t.RRx-E,_+t.RRz-k).addSegStrokeA(t.W1+t.RRx,_+t.RRz).closeSegStroke();const Bt=X(nt,_+t.Fz1).addCornerRounded(t.FR).addSegStrokeA(nt+t.FWL,_+t.Fz1).addCornerRounded(t.FR).addSegStrokeA(nt+t.FSx+t.FWH,_+t.Fz1+t.Fz2).addCornerRounded(t.FR).addSegStrokeA(nt+t.FSx,_+t.Fz1+t.Fz2).addCornerRounded(t.FR).closeSegStroke(),mt=X(0,_).addSegStrokeA(it,_).addSegStrokeA(q+rt,V+gt).addSegStrokeA(q,V).closeSegStroke(),yt=X(t.W1,_).addSegStrokeA(R,W).addSegStrokeA(R-st,W+_t).addSegStrokeA(t.W1-lt,_).closeSegStroke();c.addMainO(wt),c.addSecond(Bt),c.addSecond($t),c.addSecond(mt),c.addSecond(yt),g.mergeFigure(ut.fig.faceBeam,!0),g.addMainO(Ft),g.addMainO(Bt),g.addSecond($t),g.addSecond(mt),g.addSecond(yt),d.mergeFigure(ut.fig.faceBeam,!0),d.addSecond(wt),d.addSecond(Bt),d.addMainO($t),d.addSecond(mt),d.addSecond(yt),r.mergeFigure(ut.fig.faceBeam,!0),r.addSecond(wt),r.addSecond(Bt),r.addSecond($t),r.addMainO(mt),r.addMainO(yt),l.mergeFigure(ut.fig.faceSide,!0);const Jt=X(0,_).addSegStrokeA(t.T1,_).addSegStrokeA(t.T1,_+t.RCz-N).addSegStrokeA(0,_+t.RCz-N).closeSegStroke(),dt=X(t.W2-t.T1,_).addSegStrokeA(t.W2,_).addSegStrokeA(t.W2,_+t.RCz-N).addSegStrokeA(t.W2-t.T1,_+t.RCz-N).closeSegStroke(),oe=X(0,_).addSegStrokeA(t.W2,_).addSegStrokeA(t.W2,V).addSegStrokeA(0,V).closeSegStroke(),ne=X(0,_).addSegStrokeA(t.W2,_).addSegStrokeA(t.W2,W).addSegStrokeA(0,W).closeSegStroke(),de=X(-t.RCyb,_+t.RCz).addSegStrokeA(-t.RLyb,_+t.RLz).addSegStrokeA(t.W2+t.RLyf,_+t.RLz).addSegStrokeA(t.W2+t.RCyf,_+t.RCz).closeSegStroke(),at=X(-t.RCyb,_+t.RCz).addSegStrokeA(-t.RRyb,_+t.RRz).addSegStrokeA(t.W2+t.RRyf,_+t.RRz).addSegStrokeA(t.W2+t.RCyf,_+t.RCz).closeSegStroke();l.addSecond(dt),l.addSecond(Jt),l.addSecond(ne),l.addSecond(at),l.addMainO(oe),l.addMainO(de),e.fig={faceTop:n,faceFaceFront:c,faceFaceBack:g,faceFaceRoof:d,faceFaceSide:r,faceSide:l};const Z=e.partName;e.vol={inherits:[{outName:`inpax_${Z}_plancher`,subdesign:"pax_cabane_plancher",subgeom:ut,rotate:[0,0,0],translate:[0,0,0]}],extrudes:[{outName:`subpax_${Z}_roofTop`,face:`${Z}_faceTop`,extrudeMethod:et.eLinearOrtho,length:_+t.RCz,rotate:[0,0,0],translate:[0,0,0]},{outName:`subpax_${Z}_roofMax`,face:`${Z}_faceFaceRoof`,extrudeMethod:et.eLinearOrtho,length:Gt,rotate:[Math.PI/2,0,Math.PI/2],translate:[-Wt,0,0]},{outName:`subpax_${Z}_Wfront`,face:`${Z}_faceFaceFront`,extrudeMethod:et.eLinearOrtho,length:t.T1,rotate:[Math.PI/2,0,Math.PI/2],translate:[t.W2-t.T1,0,0]},{outName:`subpax_${Z}_Wback`,face:`${Z}_faceFaceBack`,extrudeMethod:et.eLinearOrtho,length:t.T1,rotate:[Math.PI/2,0,Math.PI/2],translate:[0,0,0]},{outName:`subpax_${Z}_Wside`,face:`${Z}_faceFaceSide`,extrudeMethod:et.eLinearOrtho,length:t.W2,rotate:[Math.PI/2,0,Math.PI/2],translate:[0,0,0]}],volumes:[{outName:`ipax_${Z}_roof`,boolMethod:Rt.eIntersection,inList:[`subpax_${Z}_roofMax`,`subpax_${Z}_roofTop`]},{outName:`pax_${Z}`,boolMethod:Rt.eUnion,inList:[`inpax_${Z}_plancher`,`ipax_${Z}_roof`,`subpax_${Z}_Wfront`,`subpax_${Z}_Wback`,`subpax_${Z}_Wside`]}]},e.sub={thePlancher:{partName:ct.getPartName(),dparam:ct.getDesignParamList(),orientation:[0,0,0],position:[0,0,567]}},e.logstr+=`cabane drawn successfully!
`,e.calcErr=!1}catch(f){e.logstr+=f,console.log(f)}return e}var bo={pTitle:"Cabane",pDescription:"La cabane des enfants",pDef:qe,pGeom:To},Ue={partName:"reinforced_tube",params:[s("D1L","mm",1600,100,4e3,1),s("H1","mm",6e3,10,2e4,10),s("E1","mm",10,1,300,1),z("Wave"),s("E2","mm",10,1,300,1),s("N2","wave",20,4,400,1),ht("W2_method",["W2_from_RW2","W2_direct"]),s("RW2","%",50,5,95,.1),s("W2","mm",80,1,800,1),s("S23L","mm",200,1,600,1),ht("D2_method",["D2_from_Rvw","D2_direct"]),s("Rvw","%",50,5,95,.1),s("D2","mm",20,1,600,1),ht("D3_method",["D3_from_R32","D3_direct"]),s("R32","%",50,5,95,.1),s("D3","mm",20,1,600,1),z("Optional internal cylinder"),Ot("internal_cylinder",!1),s("E4","mm",10,1,300,1)],paramSvg:{D1L:"reinforced_tube_section.svg",H1:"reinforced_tube_section.svg",E1:"reinforced_tube_section.svg",E2:"reinforced_tube_section.svg",N2:"reinforced_tube_section.svg",W2_method:"reinforced_tube_section.svg",RW2:"reinforced_tube_section.svg",W2:"reinforced_tube_section.svg",S23L:"reinforced_tube_section.svg",D2_method:"reinforced_tube_section.svg",R32:"reinforced_tube_section.svg",D2:"reinforced_tube_section.svg",D3_method:"reinforced_tube_section.svg",Rvw:"reinforced_tube_section.svg",D3:"reinforced_tube_section.svg",internal_cylinder:"reinforced_tube_section.svg",E4:"reinforced_tube_section.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function Mo(o,t){const i=t*Math.sin(o)/Math.sin(3*Math.PI/4-o/2),e=1-Math.cos(Math.PI/2+o);return Math.sqrt(i**2/(2*e))}function ue(o,t,i,e,n,c,g){const d=i-o,r=e-t,l=Math.sqrt(d**2+r**2),f=Math.atan2(r,d);if(l<n+c)throw`err995: CB ${a(l)} is too small compare to R1 ${a(n)} and R2 ${a(c)}`;const h=l/(1+c/n),S=l-h,A=Math.acos(n/h),u=Math.acos(c/S),x=g?1:-1,D=xt(o,t).translatePolar(f-x*A,n),m=xt(i,e).translatePolar(f+Math.PI-x*u,c);return[D.cx,D.cy,m.cx,m.cy]}function Po(o,t,i=""){const e=ft(Ue.partName+i),n=O(),c=O(),g=O(),d=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const r=t.D1L/2-t.E1,l=r-t.E2,f=2*Math.PI/t.N2,h=2*l*Math.sin(f*t.RW2/200),S=t.W2_method===0?h:t.W2,A=2*Math.asin(S/(2*l)),u=A*r,x=A*l,$=2*l*Math.sin(A/2),D=f-A,J=D*(1-t.Rvw/100)*.5,m=t.D2_method===0?Mo(J,r):t.D2/2+t.E2,_=m-t.E2,M=_*t.R32/(100-t.R32),B=t.D3_method===0?M:t.D3/2,v=B+t.E2,C=r-t.S23L+v,y=Math.asin(v/C),E=D*r;if(t.S23L<t.E2)throw`err095: S23L ${t.S23L} is too small compare to E2 ${t.E2}`;if(r-t.S23L<0)throw`err098: D1L ${t.D1L} is too small compare to E1 ${t.E1} or E2 ${t.E2}`;if(D<0)throw`err105: N2 ${t.N2} is too large compare to D1L ${t.D1L} and E1 ${t.E1}`;if(_<0)throw`err143: E2 ${t.E2} is too large compare to R2e ${a(m)}`;const k=Math.PI*t.D1L,N=2*Math.PI*r;e.logstr+=`External cylinder: D1Le: ${t.D1L} mm, D1Li: ${a(2*r)} mm, corde-ext: ${a(k)} mm, corde-int: ${a(N)} mm, diff: ${a(k-N)} mm
`,e.logstr+=`Period: angle: ${a(Q(f))} degree, corde-ext: ${a(f*r)} mm
`,e.logstr+=`W2: angle: ${a(Q(A))} degree or ${a(100*A/f)} %, corde-ext: ${a(u)} mm, corde-int: ${a(x)} mm, W2bis: ${a($)} mm
`,e.logstr+=`Wave: angle: ${a(Q(D))} degree or ${a(100*D/f)} %, corde-ext: ${a(E)} mm
`,e.logstr+=`D2: ${a(2*_)} mm, R2i: ${a(_)} mm, R2e: ${a(m)} mm
`,e.logstr+=`D3: ${a(2*B)} mm, R3i: ${a(B)} mm, R3e: ${a(v)} mm
`,n.addMainOI([G(0,0,t.D1L/2),G(0,0,t.D1L/2-t.E1)]);const T=X(r-t.E2,0),w=X(r,0),L=xt(0,0);for(let W=0;W<t.N2;W++){const b=W*f,U=L.setPolar(b+A/2,r-t.E2),it=L.setPolar(b+A,r-t.E2),lt=L.setPolar(b+A/2,r),tt=L.setPolar(b+A,r);T.addPointA(U.cx,U.cy).addPointA(it.cx,it.cy).addSegArc2(),w.addPointA(lt.cx,lt.cy).addPointA(tt.cx,tt.cy).addSegArc2();const ot=L.setPolar(b+A,r-m),rt=L.setPolar(b+A+D/2,r-t.S23L+v),gt=L.setPolar(b+A+D,r-m),[st,_t,nt,Wt]=ue(ot.cx,ot.cy,rt.cx,rt.cy,m,B,!0),[Nt,Gt,ct,ut]=ue(ot.cx,ot.cy,rt.cx,rt.cy,_,v,!0),[pt,te,ee,Ut]=ue(rt.cx,rt.cy,gt.cx,gt.cy,B,m,!1),[wt,Ft,$t,Bt]=ue(rt.cx,rt.cy,gt.cx,gt.cy,v,_,!1);T.addPointA(Nt,Gt).addSegArc(_,!1,!0),w.addPointA(st,_t).addSegArc(m,!1,!0),T.addSegStrokeA(ct,ut),w.addSegStrokeA(nt,Wt);const mt=L.setPolar(b+A+D/2,r-t.S23L),yt=L.setPolar(b+A+D/2,r-t.S23L+t.E2);T.addPointA(mt.cx,mt.cy).addPointA(wt,Ft).addSegArc2(),w.addPointA(yt.cx,yt.cy).addPointA(pt,te).addSegArc2(),T.addSegStrokeA($t,Bt),w.addSegStrokeA(ee,Ut);const Jt=L.setPolar(b+f,r-t.E2),dt=L.setPolar(b+f,r);if(T.addPointA(Jt.cx,Jt.cy).addSegArc(_,!1,!0),w.addPointA(dt.cx,dt.cy).addSegArc(m,!1,!0),W===0){const oe=$t-wt,ne=Bt-Ft,at=Math.atan2(ne,oe)-b-A-D/2,Z=at-y;e.logstr+=`af: ${a(Q(at))} degree, afDiff: ${a(Q(Z))} degree
`}}const F=T.getPerimeter(),P=w.getPerimeter();e.logstr+=`info253: Wave-internal length: ${a(F)} mm
`,e.logstr+=`info254: Wave-external length: ${a(P)} mm
`,e.logstr+=`info255: Wave-average length: ${a((P+F)/2)} mm, diff: ${a(P-F)} mm
`,c.addMainOI([w,T]),t.internal_cylinder===1&&g.addMainOI([G(0,0,r-t.S23L),G(0,0,r-t.S23L-t.E4)]),n.mergeFigure(g,!0),c.mergeFigure(n,!0),g.mergeFigure(n,!0),n.addSecond(T),n.addSecond(w),g.addSecond(T),g.addSecond(w),d.addMainO(j(-r-t.E1,0,t.E1,t.H1)),d.addMainO(j(r,0,t.E1,t.H1)),d.addSecond(j(-r,0,t.S23L,t.H1)),d.addSecond(j(r-t.S23L,0,t.S23L,t.H1)),t.internal_cylinder===1&&(d.addMainO(j(-r+t.S23L,0,t.E4,t.H1)),d.addMainO(j(r-t.S23L-t.E4,0,t.E4,t.H1))),e.fig={faceTopExt:n,faceTopWave:c,faceTopInt:g,faceSide:d};const q=e.partName,V=[],R=[];if(t.internal_cylinder===1){const W={outName:`subpax_${q}_topInt`,face:`${q}_faceTopInt`,extrudeMethod:et.eLinearOrtho,length:t.H1,rotate:[0,0,0],translate:[0,0,0]};V.push(W),R.push(`subpax_${q}_topInt`)}e.vol={extrudes:[{outName:`subpax_${q}_topExt`,face:`${q}_faceTopExt`,extrudeMethod:et.eLinearOrtho,length:t.H1,rotate:[0,0,0],translate:[0,0,0]},{outName:`subpax_${q}_topWave`,face:`${q}_faceTopWave`,extrudeMethod:et.eLinearOrtho,length:t.H1,rotate:[0,0,0],translate:[0,0,0]},...V],volumes:[{outName:`pax_${q}`,boolMethod:Rt.eUnion,inList:[`subpax_${q}_topExt`,`subpax_${q}_topWave`,...R]}]},e.logstr+=`reinforced_tube drawn successfully!
`,e.calcErr=!1}catch(r){e.logstr+=r,console.log(r)}return e}var le={pTitle:"Reinforced tube",pDescription:"A strong tube with less metal",pDef:Ue,pGeom:Po},Xe={partName:"reinforced_cone",params:[s("D1L","mm",1600,100,4e3,1),s("D1H","mm",1200,100,4e3,1),s("H1","mm",4e3,10,2e4,10),s("E1","mm",10,1,300,1),z("Wave"),s("E2","mm",10,1,300,1),s("N2","wave",20,4,400,1),ht("W2_method",["W2_from_RW2","W2_direct"],1),s("RW2","%",50,5,95,.1),s("W2","mm",80,1,800,1),s("S23L","mm",197,1,600,1),s("S23H","mm",200,1,600,1),ht("D2_method",["D2_from_Rvw","D2_direct"],1),s("Rvw","%",50,5,95,.1),s("D2","mm",30,1,600,1),ht("D3_method",["D3_from_R32","D3_direct"],1),s("R32","%",50,5,95,.1),s("D3","mm",30,1,600,1),z("Optional internal cylinder"),Ot("internal_cylinder",!0),s("E4","mm",10,1,300,1)],paramSvg:{D1L:"reinforced_tube_section.svg",D1H:"reinforced_cone_section_vertical.svg",H1:"reinforced_tube_section.svg",E1:"reinforced_tube_section.svg",E2:"reinforced_tube_section.svg",N2:"reinforced_tube_section.svg",W2_method:"reinforced_tube_section.svg",RW2:"reinforced_tube_section.svg",W2:"reinforced_tube_section.svg",S23L:"reinforced_tube_section.svg",S23H:"reinforced_cone_section_vertical.svg",D2_method:"reinforced_tube_section.svg",R32:"reinforced_tube_section.svg",D2:"reinforced_tube_section.svg",D3_method:"reinforced_tube_section.svg",Rvw:"reinforced_tube_section.svg",D3:"reinforced_tube_section.svg",internal_cylinder:"reinforced_tube_section.svg",E4:"reinforced_tube_section.svg"},sim:{tMax:100,tStep:2,tUpdate:500}};function $e(o){const t=/info255/,i=o.split(`
`).reduce((n,c)=>t.test(c)?c:n,"");return parseFloat(i.replace(/^.*length:/,"").replace(/mm,.*$/,""))}function Bo(o,t,i=""){const e=ft(Xe.partName+i),n=O(),c=O(),g=O(),d=O(),r=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const l=t.D1L/2,f=t.D1H/2,h=l-f,S=Math.sqrt(h**2+t.H1**2),A=Math.atan2(h,t.H1),u=t.E1/Math.cos(A),x=l-u-t.S23L,$=f-u-t.S23H,D=x-$,J=Math.sqrt(D**2+t.H1**2),m=Math.atan2(D,t.H1),_=t.E4/Math.cos(m),M=f*o/100+l*(100-o)/100,B=t.S23H*o/100+t.S23L*(100-o)/100;if(x-_<0)throw`err118: D1L ${t.D1L} is too small compare to S23L ${t.S23L}`;if($-_<0)throw`err121: D1H ${t.D1H} is too small compare to S23H ${t.S23H}`;e.logstr+=`Cylinder-1 (Ext): R1H: ${a(f)} mm, D1H: ${a(2*f)} mm
`,e.logstr+=`Cylinder-1 (Ext): R1L: ${a(l)} mm, D1L: ${a(2*l)} mm
`,e.logstr+=`Cylinder-1 (Ext): angle: ${a(Q(A))} degree, length: ${a(S)} mm
`,t.internal_cylinder===1&&(e.logstr+=`Cylinder-4 (Int): R4H: ${a($)} mm, D4H: ${a(2*$)} mm
`,e.logstr+=`Cylinder-4 (Int): R4L: ${a(x)} mm, D4L: ${a(2*x)} mm
`,e.logstr+=`Cylinder-4 (Int): angle: ${a(Q(m))} degree, length: ${a(J)} mm
`),e.logstr+=`Section horizontal: R1t: ${a(M)} mm, S23t: ${a(B)} mm
`;const v=bt(le.pDef,"");v.setVal("D1L",2*M),v.setVal("H1",t.H1),v.setVal("E1",t.E1),v.setVal("E2",t.E2),v.setVal("N2",t.N2),v.setVal("W2_method",t.W2_method),v.setVal("RW2",t.RW2),v.setVal("W2",t.W2),v.setVal("S23L",B),v.setVal("D2_method",t.D2_method),v.setVal("R32",t.R32),v.setVal("D2",t.D2),v.setVal("D3_method",t.D3_method),v.setVal("Rvw",t.Rvw),v.setVal("D3",t.D3),v.setVal("internal_cylinder",t.internal_cylinder),v.setVal("E4",t.E4);const C=le.pGeom(0,v.getParamVal(),v.getSuffix());vt(C);const y=$e(C.logstr);e.logstr+=Mt(C.logstr,v.getPartNameSuffix()),n.mergeFigure(C.fig.faceTopWave),d.addMainO(j(l-t.E1,0,t.E1,S).rotate(l,0,A)),d.addSecond(j(-l,0,t.E1,S).rotate(-l,0,-A)),t.internal_cylinder===1&&(d.addSecond(j(x-t.E4,0,t.E4,J).rotate(x,0,m)),d.addSecond(j(-x,0,t.E4,J).rotate(-x,0,-m))),r.mergeFigure(d,!0),t.internal_cylinder===1&&r.addMainO(j(x-t.E4,0,t.E4,J).rotate(x,0,m)),v.setVal("D1L",t.D1L),v.setVal("S23L",t.S23L);const E=le.pGeom(0,v.getParamVal(),"");vt(E);const k=$e(E.logstr);e.logstr+=`wave-low-corde length: ${a(k)} mm
`,v.setVal("D1L",t.D1H),v.setVal("S23L",t.S23H);const N=le.pGeom(0,v.getParamVal(),"");vt(N);const T=$e(N.logstr);e.logstr+=`wave-high-corde length: ${a(T)} mm
`,e.logstr+=`wave-corde low-high-diff: ${a(k-T)} mm
`;const w=T*o/100+k*(100-o)/100;e.logstr+=`wave-corde at t: ${a(o)} %, expected length: ${a(w)} mm
`,e.logstr+=`wave-corde-t length: ${a(y)} mm, diff: ${a(y-w)} mm
`,c.mergeFigure(N.fig.faceTopWave),g.mergeFigure(E.fig.faceTopWave),e.fig={faceTopWave:n,faceSideExt:d,faceSideInt:r,faceTopWaveH:c,faceTopWaveL:g};const L=e.partName,F=[],P=[];if(t.internal_cylinder===1){const q={outName:`subpax_${L}_SideInt`,face:`${L}_faceSideInt`,extrudeMethod:et.eRotate,rotate:[0,0,0],translate:[0,0,0]};F.push(q),P.push(`subpax_${L}_SideInt`)}e.vol={extrudes:[{outName:`subpax_${L}_SideExt`,face:`${L}_faceSideExt`,extrudeMethod:et.eRotate,rotate:[0,0,0],translate:[0,0,0]},...F],volumes:[{outName:`pax_${L}`,boolMethod:Rt.eUnion,inList:[`subpax_${L}_SideExt`,...P]}]},e.logstr+=`reinforced_cone drawn successfully!
`,e.calcErr=!1}catch(l){e.logstr+=l,console.log(l)}return e}var Co={pTitle:"Reinforced cone",pDescription:"A strong cone with less metal",pDef:Xe,pGeom:Bo},Ze={partName:"sfDie",params:[s("W1","mm",200,10,500,1),s("J1","degree",90,-200,200,1),s("J5","degree",90,-200,200,1),s("D1","mm",50,1,100,1),z("Thickness and fold"),s("Th","mm",10,1,20,1),s("Jradius","mm",20,1,50,1),s("Jneutral","%",50,0,100,1),s("Jmark","mm",1,0,20,.1)],paramSvg:{W1:"sfDie_pattern.svg",J1:"sfDie_pattern.svg",J5:"sfDie_pattern.svg",D1:"sfDie_pattern.svg",Th:"sfDie_pattern.svg",Jradius:"sfDie_pattern.svg",Jneutral:"sfDie_pattern.svg",Jmark:"sfDie_pattern.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function Eo(o,t,i=""){const e=ft(Ze.partName+i);e.logstr+=`${e.partName} simTime: ${o}
`;try{const n=t.Jneutral/100,c=t.Jradius,g=t.Jmark,d=c-t.Th*n,r=c+t.Th*(1-n),l=t.W1/2,f=t.W1/3,h=t.W1/4,S=t.D1/2;if(c<t.Th)throw`err107: Jradius ${c} is smaller than Th ${t.Th}`;if(3*t.D1>t.W1)throw`err108: D1 ${t.D1} is too large compare to W1 ${t.W1}`;e.logstr+=`junction: radius neutral ${a(c)}, intern ${a(d)}, extern ${a(r)}
`;const A=K(0,0).startJunction("J1",I.eA,H.eABLeft).addSegStrokeR(t.W1,0).startJunction("J2",I.eA,H.eABLeft).addSegStrokeR(0,t.W1).startJunction("J3",I.eA,H.eABLeft).addSegStrokeR(-t.W1,0).startJunction("J4",I.eA,H.eABLeft).closeSegStroke(),u=G(l,l,S),x=Y([A,u]),$=K(0,0).addSegStrokeR(t.W1,0).startJunction("J5",I.eA,H.eABLeft).addSegStrokeR(0,t.W1).addSegStrokeR(-t.W1,0).startJunction("J2",I.eB,H.eABRight).closeSegStroke(),D=G(f,f,S),J=G(2*f,2*f,S),m=Y([$,D,J]),_=K(0,0).addSegStrokeR(t.W1,0).addSegStrokeR(0,t.W1).startJunction("J1",I.eB,H.eABRight).addSegStrokeR(-t.W1,0).closeSegStroke(),M=G(h,h,S),B=G(l,l,S),v=G(3*h,3*h,S),C=Y([_,M,B,v]),y=K(0,0).startJunction("J3",I.eB,H.eABRight).addSegStrokeR(t.W1,0).addSegStrokeR(0,t.W1).addSegStrokeR(-t.W1,0).closeSegStroke(),E=[];E.push(G(h,h,S)),E.push(G(h,3*h,S)),E.push(G(3*h,h,S)),E.push(G(3*h,3*h,S));const k=Y([y,...E]),N=K(0,0).addSegStrokeR(t.W1,0).startJunction("J4",I.eB,H.eABRight).addSegStrokeR(0,t.W1).addSegStrokeR(-t.W1,0).closeSegStroke(),T=[];T.push(G(l,l,S)),T.push(G(h,h,S)),T.push(G(3*h,h,S)),T.push(G(h,3*h,S)),T.push(G(3*h,3*h,S));const w=Y([N,...T]),L=K(0,0).addSegStrokeR(t.W1,0).startJunction("J5",I.eB,H.eABRight).addSegStrokeR(0,t.W1).addSegStrokeR(-t.W1,0).closeSegStroke(),F=[];F.push(G(h,h,S)),F.push(G(2*h,h,S)),F.push(G(3*h,h,S)),F.push(G(h,3*h,S)),F.push(G(2*h,3*h,S)),F.push(G(3*h,3*h,S));const P=Y([L,...F]),q=["J1",t.W1],V=["J1",t.W1,"J5",t.W1],R=qt([x,m,C,k,w,P],{J1:{angle:p(t.J1),radius:c,neutral:n,mark:g},J2:{angle:p(t.J1),radius:c,neutral:n,mark:g},J3:{angle:p(t.J1),radius:c,neutral:n,mark:g},J4:{angle:p(t.J1),radius:c,neutral:n,mark:g},J5:{angle:p(t.J5),radius:c,neutral:n,mark:g}},[{x1:0,y1:0,a1:0,l1:t.W1,ante:q,post:q},{x1:0,y1:1.5*t.W1,a1:0,l1:t.W1,ante:q,post:V}],t.Th,e.partName),W=R.makeFigures();for(const b of Object.keys(W))e.fig[b]=W[b];e.vol=R.makeVolume(),e.sub={},e.logstr+=`sfDie drawn successfully!
`,e.calcErr=!1}catch(n){e.logstr+=n,console.log(n)}return e}var No={pTitle:"sfDie",pDescription:"a die (or dice) made out metal sheet",pDef:Ze,pGeom:Eo},Ke={partName:"sfTube",params:[s("H1","mm",2e3,100,1e4,1),s("D1","mm",200,1,2e3,1),s("D2","mm",500,1,5e3,1),s("N1","facet",6,3,200,1),z("Thickness and fold"),s("Th","mm",10,1,20,1),s("Jradius","mm",20,1,50,1),s("Jneutral","%",50,0,100,1),s("Jmark","mm",1,0,20,.1)],paramSvg:{H1:"sfTube_top.svg",D1:"sfTube_top.svg",D2:"sfTube_top.svg",N1:"sfTube_pattern.svg",Th:"sfTube_top.svg",Jradius:"sfTube_pattern.svg",Jneutral:"sfTube_top.svg",Jmark:"sfTube_pattern.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function wo(o,t,i=""){const e=ft(Ke.partName+i);e.logstr+=`${e.partName} simTime: ${o}
`;try{const n=t.Jneutral/100,c=t.Jradius,g=t.Jmark,d=2*Math.PI/t.N1,r=Math.PI-d,l=t.D1/2,f=t.D2/2;if(f<l)throw`err109: D2 ${t.D2} is smaller than D1 ${t.D1}`;const h=Math.atan2(t.H1,f-l),S=Math.atan2(t.H1,(f-l)*Math.cos(d/2)),A=l*2*Math.sin(d/2),u=f*2*Math.sin(d/2),x=(u-A)/2,$=t.H1/Math.sin(h),D=Math.acos(x/$),J=u*Math.sin(D),[m,_]=Yt(u,r,u),[M,B]=Pt(J,m,J),v=D,C=Math.PI-M,E=c/Math.tan(C/2)/Math.sin(v),k=u-2*E,N=A-2*E,T=Math.sqrt($**2-x**2);if(c<n*t.Th)throw`err107: Jradius ${c} is too small compare to Th ${t.Th} and Jneutral ${t.Jneutral}`;if(N<.01)throw`err126: TW1 ${a(N)} is negative or too close to zero`;e.logstr+=_+B,e.logstr+=`Cone tilt: Tilt1 ${a(Q(h))} degree, Tilt2 ${a(Q(S))} degree
`,e.logstr+=`Polygone: N1 ${t.N1}, W1 ${a(A)}, W2 ${a(u)} mm, CAB2 ${a(Q(r))} degree
`,e.logstr+=`Trapeze: a1 ${a(Q(v))} degree, T1 ${a(T)}, TW1 ${a(N)}, TW2 ${a(k)} mm
`,e.logstr+=`Joint: L1 ${a($)} mm, Jangle ${a(Q(C))} degree, JW ${a(C*c)} mm
`;const w=[],L={},F=[],P=[];for(let R=0;R<t.N1;R++){const W=`J${R+1}`,b=`J${R}`,U=K(-u/2,0).addSegStrokeR(u,0).startJunction(W,I.eA,H.eABLeft).addSegStrokeR(-x,T).addSegStrokeR(-A,0);R>0&&U.startJunction(b,I.eB,H.eABRight),U.closeSegStroke();const it=Y([U]);w.push(it),L[W]={angle:C,radius:c,neutral:n,mark:g},R>0&&(F.push(b),F.push(N),P.push(b),P.push(k))}const q=qt(w,L,[{x1:0,y1:0,a1:0,l1:N,ante:[],post:F},{x1:0,y1:4*k,a1:0,l1:k,ante:[],post:P}],t.Th,e.partName),V=q.makeFigures();for(const R of Object.keys(V))e.fig[R]=V[R];e.vol=q.makeVolume(),e.sub={},e.logstr+=`sfTube drawn successfully!
`,e.calcErr=!1}catch(n){e.logstr+=n,console.log(n)}return e}var Fo={pTitle:"sfTube",pDescription:"a conic tube made out metal sheet",pDef:Ke,pGeom:wo},Qe={partName:"multiFacets",params:[s("D1","mm",200,10,500,1),s("E2","mm",20,10,500,1),s("N1","",3,1,8,1),z("Foot"),s("W1","mm",50,1,200,1),s("W2","mm",50,1,200,1),s("W3","mm",50,1,200,1),s("W4","mm",50,1,200,1),s("E1","mm",5,1,20,1),s("R1","mm",5,1,20,1),z("Intern"),s("V1","mm",20,1,200,1),s("V2","mm",15,1,200,1),s("V3","mm",30,1,200,1),s("V4","mm",80,1,200,1),z("Thickness and fold"),s("Th","mm",10,1,20,1),s("Jangle","degree",45,-120,120,.1),s("JradiusF","mm",20,1,50,1),s("JradiusI","mm",10,1,50,1),s("Jneutral","%",50,0,100,1),s("Jmark","mm",1,0,20,.1)],paramSvg:{D1:"multiFacets_overview.svg",E2:"multiFacets_overview.svg",N1:"multiFacets_overview.svg",W1:"multiFacets_foot.svg",W2:"multiFacets_foot.svg",W3:"multiFacets_foot.svg",W4:"multiFacets_foot.svg",E1:"multiFacets_foot.svg",R1:"multiFacets_foot.svg",V1:"multiFacets_intern.svg",V2:"multiFacets_intern.svg",V3:"multiFacets_intern.svg",V4:"multiFacets_intern.svg",Th:"multiFacets_overview.svg",Jangle:"multiFacets_overview.svg",JradiusF:"multiFacets_overview.svg",JradiusI:"multiFacets_overview.svg",Jneutral:"multiFacets_overview.svg",Jmark:"multiFacets_overview.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function Io(o,t,i=""){const e=ft(Qe.partName+i);e.logstr+=`${e.partName} simTime: ${o}
`;try{const n=t.Jneutral/100,c=t.JradiusF,g=t.JradiusI,d=t.Jmark,r=p(t.Jangle),l=t.D1/2,f=l+t.E2,h=t.V1/2,S=Math.sqrt(l**2-h**2),A=t.W1/2,u=Math.sqrt(f**2-A**2),x=Math.asin(A/f),$=Math.PI/t.N1-x,D=t.W1/6,J=(t.W4+t.W2)/6,m=4*D-2*t.E1,_=(t.V4-t.V1)/2,M=t.V1/8,B=t.V4/16;if(c<n*t.Th)throw`err107: JradiusF ${c} is too small compare to Th ${t.Th} and Jneutral ${t.Jneutral}`;if(g<n*t.Th)throw`err107: JradiusI ${g} is too small compare to Th ${t.Th} and Jneutral ${t.Jneutral}`;if($<.001)throw`err132: aW12b ${a($)} is negative or quasi-negative`;if(_<.1)throw`err147: V4 ${t.V4} is too small compare to V1 ${t.V1}`;e.logstr+=`multiFacets: N1 ${t.N1}
`;const v={},C=K(u,A);for(let P=0;P<t.N1;P++){const q=`Jf${P}1`,R=P*(2*$+2*x)+x+$,W=R+$,b=W+2*x;C.addPointAP(R,f).addPointAP(W,f).addSegArc2().startJunction(q,I.eA,H.eABLeft),P<t.N1-1?C.addSegStrokeAP(b,f):C.closeSegStroke(),v[q]={angle:-r,radius:c,neutral:n,mark:d}}const y=K(h,-S).addPointA(l,0).addPointA(h,S).addSegArc2().startJunction("Ji11",I.eA,H.eABRight).addSegStrokeA(-h,S).addPointA(-l,0).addPointA(-h,-S).addSegArc2().startJunction("Ji21",I.eA,H.eABRight).closeSegStroke(),E=Y([C,y]),k=[],N={};for(let P=0;P<t.N1;P++){const q=`Jf${P}1`,V=`Jf${P}2`,R=`Jf${P}3`,W=`Jf${P}4`,b=`Jf${P}6`,U=`Jf${P}8`,it=K(0,0).startJunction(q,I.eB,H.eABRight).addSegStrokeR(t.W1,0).addSegStrokeR(0,t.W4).startJunction(V,I.eA,H.eABLeft).addSegStrokeR(0,t.W2).addSegStrokeR(-t.W1,0).startJunction(R,I.eA,H.eABLeft).addSegStrokeR(0,-t.W2).closeSegStroke(),lt=K(D,J).addSegStrokeR(4*D,0).addSegStrokeR(0,4*J).addSegStrokeR(-t.E1,0).startJunction(W,I.eA,H.eABRight).addSegStrokeR(-m,0).addSegStrokeR(-t.E1,0).closeSegStroke(),tt=K(0,0).addSegStrokeR(m,0).addSegStrokeR(0,2*J).startJunction(W,I.eA,H.eABLeft).addSegStrokeR(-m,0).closeSegStroke(),ot=K(0,0).startJunction(V,I.eB,H.eABRight).addSegStrokeR(t.W2,0).addSegStrokeR(0,t.W3).startJunction(b,I.eA,H.eABLeft).addSegStrokeR(-t.W2,0).closeSegStroke(),rt=K(0,0).startJunction(b,I.eB,H.eABRight).addSegStrokeR(t.W2,0).addSegStrokeR(0,t.W3).addSegStrokeR(-t.W2,0).closeSegStroke(),gt=K(0,0).startJunction(R,I.eB,H.eABRight).addSegStrokeR(t.W2,0).addSegStrokeR(0,t.W3).startJunction(U,I.eA,H.eABLeft).addSegStrokeR(-t.W2,0).closeSegStroke(),st=K(0,0).startJunction(U,I.eB,H.eABRight).addSegStrokeR(t.W2,0).addSegStrokeR(0,t.W3).addSegStrokeR(-t.W2,0).closeSegStroke();N[V]={angle:-r,radius:c,neutral:n,mark:d},N[R]={angle:-r,radius:c,neutral:n,mark:d},N[W]={angle:2*r,radius:c,neutral:n,mark:d},N[b]={angle:r,radius:c,neutral:n,mark:d},N[U]={angle:r,radius:c,neutral:n,mark:d};const _t=Math.min(m/2,J)*2/3,nt=Math.min(t.W2/2,t.W3)*2/3;k.push(Y([it,lt])),k.push(Y([tt,G(m/2,J,_t)])),k.push(Y([ot])),k.push(Y([rt,G(t.W2/2,t.W3/2,nt)])),k.push(Y([gt])),k.push(Y([st,G(t.W2/2,t.W3/2,nt)]))}const T=[],w={};for(let P=0;P<2;P++){const q=`Ji${P+1}1`,V=`Ji${P+1}2`,R=`Ji${P+1}3`,W=`Ji${P+1}4`,b=`Ji${P+1}5`,U=`Ji${P+1}6`,it=`Ji${P+1}7`,lt=K(0,0).startJunction(q,I.eA,H.eABLeft).addSegStrokeR(t.V1,0).addSegStrokeR(0,t.V2).startJunction(V,I.eA,H.eABLeft).addSegStrokeR(-t.V1,0).closeSegStroke(),tt=K(0,0).startJunction(V,I.eA,H.eABRight).addSegStrokeR(-t.V1,0).addSegStrokeR(-t.V3,t.V3).startJunction(R,I.eB,H.eABLeft).addSegStrokeR(t.V1,0).closeSegStroke(),ot=K(0,0).startJunction(R,I.eB,H.eABRight).addSegStrokeR(t.V1,0).addSegStrokeR(0,t.V4).startJunction(W,I.eA,H.eABLeft).addSegStrokeR(-t.V1,0).addSegStrokeR(0,-_).startJunction(b,I.eA,H.eABLeft).addSegStrokeR(0,-t.V1).closeSegStroke(),rt=K(M,B).addSegStrokeR(M,0).startJunction(U,I.eA,H.eABRight).addSegStrokeR(4*M,0).addSegStrokeR(M,0).addSegStrokeR(0,14*B).addSegStrokeR(-M,0).startJunction(it,I.eA,H.eABRight).addSegStrokeR(-4*M,0).addSegStrokeR(-M,0).closeSegStroke(),gt=K(0,0).startJunction(W,I.eB,H.eABRight).addSegStrokeR(t.V1,0).addSegStrokeR(0,t.V2).addSegStrokeR(-t.V1,0).closeSegStroke(),st=j(t.V1/6,t.V2/6,t.V1*2/3,t.V2*2/3),_t=K(0,0).startJunction(b,I.eB,H.eABRight).addSegStrokeR(t.V1,0).addSegStrokeR(0,t.V2).addSegStrokeR(-t.V1,0).closeSegStroke(),nt=K(0,0).startJunction(U,I.eA,H.eABLeft).addSegStrokeR(4*M,0).addSegStrokeR(0,4*B).addSegStrokeR(-4*M,0).closeSegStroke(),Wt=K(0,0).startJunction(it,I.eA,H.eABLeft).addSegStrokeR(4*M,0).addSegStrokeR(0,4*B).addSegStrokeR(-4*M,0).closeSegStroke(),Nt=Math.min(2*M,2*B)*2/3;w[q]={angle:2*r,radius:g,neutral:n,mark:d},w[V]={angle:-r,radius:g,neutral:n,mark:d},w[R]={angle:-r,radius:g,neutral:n,mark:d},w[W]={angle:2*r,radius:g,neutral:n,mark:d},w[b]={angle:2*r,radius:g,neutral:n,mark:d},w[U]={angle:2*r,radius:g,neutral:n,mark:d},w[it]={angle:2*r,radius:g,neutral:n,mark:d},T.push(Y([lt])),T.push(Y([tt])),T.push(Y([ot,rt])),T.push(Y([gt,st])),T.push(Y([_t])),T.push(Y([nt,G(2*M,2*B,Nt)])),T.push(Y([Wt,G(2*M,2*B,Nt)]))}const L=qt([E,...k,...T],{...v,...N,...w},[{x1:0,y1:0,a1:0,l1:t.E2,ante:["Ji11",t.V2,"Ji12",t.V3,"Ji13",t.V4,"Ji14",t.V2],post:["Jf11",t.W4+t.W2,"Jf12",t.W3,"Jf16",t.W3]}],t.Th,e.partName),F=L.makeFigures();for(const P of Object.keys(F))e.fig[P]=F[P];e.vol=L.makeVolume(),e.sub={},e.logstr+=`multiFacets drawn successfully!
`,e.calcErr=!1}catch(n){e.logstr+=n,console.log(n)}return e}var Ho={pTitle:"multiFacets",pDescription:"a shape for testing sheetfold",pDef:Qe,pGeom:Io},Ye={partName:"sfCheck",params:[s("L1","mm",200,10,500,1),s("W1","mm",100,10,500,1),z("Thickness and fold"),s("Th","mm",10,1,20,1),s("Jangle","degree",90,-120,120,.1),s("Jradius","mm",10,1,50,1),s("Jneutral","%",50,0,100,1),s("Jmark","mm",1,0,20,.1)],paramSvg:{L1:"sfCheck_overview.svg",W1:"sfCheck_overview.svg",Th:"sfCheck_overview.svg",Jangle:"sfCheck_overview.svg",Jradius:"sfCheck_overview.svg",Jneutral:"sfCheck_overview.svg",Jmark:"sfCheck_overview.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function Vo(o,t,i=""){const e=ft(Ye.partName+i);e.logstr+=`${e.partName} simTime: ${o}
`;try{const n=t.Jneutral/100,c=t.Jradius,g=t.Jmark,d=p(t.Jangle),r=t.L1/20,l=t.W1/20,f=Math.min(3*r,10*l)/2;if(c<n*t.Th)throw`err107: Jradius ${c} is too small compare to Th ${t.Th} and Jneutral ${t.Jneutral}`;e.logstr+=`sfCheck: L1 ${t.L1} W1 ${t.W1} rHollow ${f} mm
`;const h=K(0,0).addSegStrokeR(10*r,0).startJunction("J1",I.eA,H.eABLeft).addSegStrokeR(0,16*l).addSegStrokeR(-10*r,0).closeSegStroke(),S=K(r,l).addSegStrokeR(8*r,0).addSegStrokeR(0,1*l).startJunction("J2",I.eA,H.eABRight).addSegStrokeR(0,12*l).addSegStrokeR(0,1*l).addSegStrokeR(-8*r,0).closeSegStroke(),A=Y([h,S]),u=K(0,0).addSegStrokeR(20*r,0).addSegStrokeR(0,20*l).addSegStrokeR(-20*r,0).closeSegStroke(),x=K(r,l).addSegStrokeR(18*r,0).addSegStrokeR(0,1*l).startJunction("J1",I.eA,H.eABRight).addSegStrokeR(0,16*l).addSegStrokeR(0,1*l).addSegStrokeR(-18*r,0).addSegStrokeR(0,-1*l).startJunction("J3",I.eA,H.eABRight).addSegStrokeR(0,-16*l).closeSegStroke(),$=Y([u,x]),D=K(0,0).addSegStrokeR(4*r,0).addSegStrokeR(0,16*l).addSegStrokeR(-4*r,0).startJunction("J3",I.eA,H.eABLeft).closeSegStroke(),J=G(2*r,8*l,f),m=Y([D,J]),_=K(0,0).addSegStrokeR(4*r,0).startJunction("J2",I.eA,H.eABLeft).addSegStrokeR(0,12*l).addSegStrokeR(-4*r,0).closeSegStroke(),M=G(2*r,6*l,f),B=Y([_,M]),v=qt([A,$,m,B],{J1:{angle:-d,radius:c,neutral:n,mark:g},J2:{angle:d,radius:c,neutral:n,mark:g},J3:{angle:-d,radius:c,neutral:n,mark:g}},[{x1:0,y1:0,a1:0,l1:r,ante:["J2",4*r],post:["J1",r]},{x1:0,y1:4*t.W1,a1:0,l1:r,ante:[],post:["J3",4*r]}],t.Th,e.partName),C=v.makeFigures();for(const y of Object.keys(C))e.fig[y]=C[y];e.vol=v.makeVolume(),e.sub={},e.logstr+=`sfCheck drawn successfully!
`,e.calcErr=!1}catch(n){e.logstr+=n,console.log(n)}return e}var jo={pTitle:"sfCheck",pDescription:"an other shape for testing sheetfold",pDef:Ye,pGeom:Vo},Oo=0,Go=1,zo=2,qo=3;function he(o,t){const i=Math.tan(o.aa),e=Math.tan(t.aa),n=i-e;if(n===0)throw`err073: error of parallel line intersection. a1: ${a(o.aa)} a2: ${a(t.aa)}`;const c=(t.yy-o.yy-t.xx*e+o.xx*i)/n,g=i*(c-o.xx)+o.yy;return{ix:c,iy:g,refR:0}}function Uo(o,t,i,e,n){const c=Math.tan(o.aa),g=c**2+1,d=2*c*(o.yy-o.xx*c)-2*t,r=(o.yy-o.xx*c)**2-i**2+t**2,l=d**2-4*g*r;if(l<0)throw`err090: D ${a(l)} < 0. The ray is out of the circle`;const f=(-d-e*Math.sqrt(l))/(2*g),h=o.yy+(f-o.xx)*c,S=Re(Math.atan2(h,f-t));if(Math.abs(S)>n)throw`err097: refR ${a(S)} out of lens-angle ${a(n)}`;return{ix:f,iy:h,refR:S}}function Be(o,t){const i={xx:0,yy:0,aa:0};if(t.signe===0)i.xx=t.cx,i.yy=o.yy+(t.cx-o.xx)*Math.tan(o.aa),i.aa=Math.asin(Math.sin(o.aa)*t.n0/t.n1);else{const e=Uo(o,t.cx,t.radius,t.signe,t.angle);i.xx=e.ix,i.yy=e.iy,i.aa=e.refR+Math.asin(Math.sin(o.aa-e.refR)*t.n0/t.n1)}return i}function Se(o){let t=0;return o===0?t=1:o===2&&(t=-1),t}function Xo(o,t,i){const e={n0:t,n1:i.ni,signe:Se(i.TypeL),cx:i.PosX-i.E1/2+Se(i.TypeL)*i.Rl,radius:i.Rl,angle:Math.asin(i.Dl/(2*i.Rl))},n={n0:i.ni,n1:t,signe:-Se(i.TypeR),cx:i.PosX+i.E1/2-Se(i.TypeR)*i.Rr,radius:i.Rr,angle:Math.asin(i.Dr/(2*i.Rr))},c=Be(o,e),g=Be(c,n);return[c,g]}function Zo(o,t){const e=(t-o.xx)*Math.tan(o.aa);return o.yy+e}function Zt(o,t,i,e){const n=X(o.xx,o.yy,"yellow"),c={xx:o.xx,yy:o.yy,aa:o.aa};for(const r of i){const[l,f]=Xo(c,t,r);n.addSegStrokeA(l.xx,l.yy).addSegStrokeA(f.xx,f.yy),c.xx=f.xx,c.yy=f.yy,c.aa=f.aa}const g=e*1.2,d=Zo(c,g);return n.addSegStrokeA(g,d),[n,c]}function pe(o,t,i,e,n,c,g,d,r){const l=[],f=p(i),h=p(e);let S=`Optic simulator:
ray1-angle1: ${a(Q(f))}
ray2-angle1: ${a(Q(h))}
rayNb: ${n}
simType: ${c}
`;for(let $=0;$<d.length;$++)S+=`lens-${$+1}
  E1: ${d[$].E1}
  Dioptre-left  :  Dl: ${d[$].Dl}, Rl: ${d[$].Rl}, TypeL: ${d[$].TypeL}
  Dioptre-right :  Dr: ${d[$].Dr}, Rr: ${d[$].Rr}, TypeR: ${d[$].TypeR}
  index of refraction of the lens: ni: ${d[$].ni}
  Position-X: ${d[$].PosX} mm
`;S+=`index of refraction of the environment: n0: ${g}
`;const A={xx:o,yy:t,aa:f},u={xx:o,yy:t,aa:h},x=d[0].Dl*.98;if(c===Oo){const[$]=Zt(A,g,d,r);l.push($)}else if(c===Go){const[$,D]=Zt(A,g,d,r),[J,m]=Zt(u,g,d,r);l.push($,J);const _=he(D,m);S+=`ray intersection:  ix: ${a(_.ix)}, iy: ${a(_.iy)}
`}else{const $=[];if(c===zo)if(n<2){const D=o*Math.tan(f),J={xx:o,yy:D,aa:f},[m]=Zt(J,g,d,r);l.push(m)}else{const D=o*Math.tan(f)-x/2,J=x/(n-1);for(let m=0;m<n;m++){const _={xx:o,yy:D+m*J,aa:f},[M,B]=Zt(_,g,d,r);l.push(M),$.push(B)}}else if(c===qo)if(n<2){const D=Re(Math.atan2(t,o)),J={xx:o,yy:t,aa:D},[m]=Zt(J,g,d,r);l.push(m)}else{const D=Re(Math.atan2(t+x/2,o)),m=(Re(Math.atan2(t-x/2,o))-D)/(n-1);for(let _=0;_<n;_++){const M={xx:o,yy:t,aa:D+_*m},[B,v]=Zt(M,g,d,r);l.push(B),$.push(v)}}if(n>1){const D=he($[0],$[1]);if(S+=`ray intersection:  ix: ${a(D.ix)}, iy: ${a(D.iy)}
`,n>2){const J=he($.slice(-2)[0],$.slice(-1)[0]),m=he($[0],$.slice(-1)[0]),_=Math.abs(J.ix-D.ix),M=Math.abs(m.ix-J.ix),B=Math.abs(m.ix-D.ix),v=Math.abs(J.iy-D.iy),C=Math.abs(m.iy-J.iy),y=Math.abs(m.iy-D.iy),E=Math.max(_,M,B),k=Math.max(v,C,y);S+=`aberration:  aberX: ${a(E)}, aberY: ${a(k)}
`}}}return S+=`End of simulator
`,[l,S]}var to={partName:"lens_x1",params:[s("D1","mm",40,1,500,1),s("E1","mm",8,.5,200,.5),z("Dioptre left"),s("Dl","mm",30,1,500,1),s("Rl","mm",35,1,5e3,.1),ht("TypeL",["convex","planar","concave"]),z("Dioptre right"),s("Dr","mm",30,1,500,1),s("Rr","mm",50,1,5e3,.1),ht("TypeR",["convex","planar","concave"]),z("index of refraction"),s("ni","no-unit",1.6,1,3,.01),s("ne","no-unit",1,1,3,.01),z("Simulation"),s("objectPx","mm",-50,-500,0,1),s("objectPy","mm",8,-500,500,1),s("ray1Angle","degree",0,-60,60,1),s("ray2Angle","degree",-2,-60,60,1),s("rayNb","rays",3,1,100,1),s("imagePx","mm",120,0,2e3,1),ht("simType",["oneRay","twoRays","parallel","object"])],paramSvg:{D1:"lens_profile.svg",E1:"lens_profile.svg",Dl:"lens_profile.svg",Rl:"lens_profile.svg",TypeL:"lens_profile.svg",Dr:"lens_profile.svg",Rr:"lens_profile.svg",TypeR:"lens_profile.svg",ni:"lens_profile.svg",ne:"lens_profile.svg",objectPx:"lens_simOneRay.svg",objectPy:"lens_simOneRay.svg",ray1Angle:"lens_simOneRay.svg",ray2Angle:"lens_simTwoRays.svg",rayNb:"lens_simParallel.svg",imagePx:"lens_simOneRay.svg",simType:"lens_simObject.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function Ce(o,t,i){let e=0;const n=t/2,c=o*(1-Math.sqrt(1-(n/o)**2));return i===0?e=c:i===2&&(e=-1*c),e}function Ko(o,t,i=""){const e=ft(to.partName+i),n=O(),c=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{let d=function(E,k){const N=X(A,0);return t.TypeR!==1&&N.addPointA($,E*r).addSegArc3(E*Math.PI/2,!0),N.addSegStrokeA($,E*u).addSegStrokeA(x,E*u),t.TypeL!==1?N.addSegStrokeA(x,E*l).addPointA(-A,0).addSegArc3(E*Math.PI/2,!1):N.addSegStrokeA(-A,0),k&&N.closeSegStroke(),N};var g=d;const r=t.Dr/2,l=t.Dl/2,f=Ce(t.Rl,t.Dl,t.TypeL),h=Ce(t.Rr,t.Dr,t.TypeR),S=t.E1-f-h,A=t.E1/2,u=t.D1/2,x=-A+f,$=A-h;if(t.Dr>t.D1)throw`err390: Dr ${t.Dr} is larger than D1 ${t.D1}`;if(t.Dl>t.D1)throw`err393: Dl ${t.Dl} is larger than D1 ${t.D1}`;if(S<0)throw`err396: E2 ${a(S)} is negative because of E1pL ${a(f)} or E1pR ${a(h)}`;e.logstr+=`E2: ${a(S)} mm
`,e.logstr+=`x1: ${a(x)}, x2: ${a($)} mm
`;const D=d(1,!1);t.TypeL!==1&&D.addPointA(-A+f,-l).addSegArc3(-Math.PI/2,!0),D.addSegStrokeA(-A+f,-u).addSegStrokeA(A-h,-u),t.TypeR!==1?D.addSegStrokeA(A-h,-r).addPointA(A,0).addSegArc3(-Math.PI/2,!1):D.addSegStrokeA(A,0),n.addMainO(D);const J=X(t.objectPx,t.objectPy,"green");J.addSegStrokeA(t.objectPx,0),n.addDynamics(J);const m=X(t.imagePx,-u,"green");m.addSegStrokeA(t.imagePx,u),n.addDynamics(m);const _=1.2*t.imagePx-t.objectPx;n.addVector(ie(0,_,xt(t.objectPx,0)));const M=X(t.objectPx,0,"grey").addSegStrokeR(_,0);n.addDynamics(M);const B={E1:t.E1,Dl:t.Dl,Rl:t.Rl,TypeL:t.TypeL,Dr:t.Dr,Rr:t.Rr,TypeR:t.TypeR,ni:t.ni,PosX:0},[v,C]=pe(t.objectPx,t.objectPy,t.ray1Angle,t.ray2Angle,t.rayNb,t.simType,t.ne,[B],t.imagePx);for(const E of v)n.addDynamics(E);e.logstr+=C,c.addMainO(d(1,!0).rotate(0,0,Math.PI/2)),c.addSecond(d(-1,!0).rotate(0,0,Math.PI/2)),e.fig={faceLensSim:n,faceLens3D:c};const y=e.partName;e.vol={extrudes:[{outName:`subpax_${y}`,face:`${y}_faceLens3D`,extrudeMethod:et.eRotate,rotate:[0,0,0],translate:[0,0,0]}],volumes:[{outName:`pax_${y}`,boolMethod:Rt.eIdentity,inList:[`subpax_${y}`]}]},e.sub={},e.logstr+=`lens_x1 drawn successfully!
`,e.calcErr=!1}catch(d){e.logstr+=d,console.log(d)}return e}var Kt={pTitle:"Lens_x1",pDescription:"A single spherical lens",pDef:to,pGeom:Ko};function De(){return{D1:0,E1:0,Rl:0,Dl:0,TypeL:0,Rr:0,Dr:0,TypeR:0,Drh:0,Dlh:0,E1pL:0,E1pR:0,E2:0,E1h:0,D1h:0,x1:0,x2:0}}function se(o,t,i){let e=0;const n=t/2,c=o*(1-Math.sqrt(1-(n/o)**2));return i===0?e=c:i===2&&(e=-1*c),e}function ve(o,t){if(o.Dr>o.D1)throw`err390: ${t} : Dr ${o.Dr} is larger than D1 ${o.D1}`;if(o.Dl>o.D1)throw`err393: ${t} : Dl ${o.Dl} is larger than D1 ${o.D1}`;if(o.E2<0)throw`err396:${t} :  E2 ${a(o.E2)} is negative because of E1pL ${a(o.E1pL)} or E1pR ${a(o.E1pR)}`}function me(o,t){return`${t} : E2: ${a(o.E2)} mm
${t} : x1: ${a(o.x1)}, x2: ${a(o.x2)} mm
`}function Vt(o,t,i,e){const n=X(t+o.E1h,0);return o.TypeR!==1&&n.addPointA(t+o.x2,i*o.Drh).addSegArc3(i*Math.PI/2,!0),n.addSegStrokeA(t+o.x2,i*o.D1h).addSegStrokeA(t+o.x1,i*o.D1h),o.TypeL!==1?n.addSegStrokeA(t+o.x1,i*o.Dlh).addPointA(t-o.E1h,0).addSegArc3(i*Math.PI/2,!1):n.addSegStrokeA(t-o.E1h,0),e&&n.closeSegStroke(),n}function ke(o,t,i){t.TypeL!==1&&o.addPointA(i-t.E1h+t.E1pL,-t.Dlh).addSegArc3(-Math.PI/2,!0),o.addSegStrokeA(i-t.E1h+t.E1pL,-t.D1h).addSegStrokeA(i+t.E1h-t.E1pR,-t.D1h),t.TypeR!==1?o.addSegStrokeA(i+t.E1h-t.E1pR,-t.Drh).addPointA(i+t.E1h,0).addSegArc3(-Math.PI/2,!1):o.addSegStrokeA(i+t.E1h,0)}var eo={partName:"lens_x3",params:[s("ne","no-unit",1,1,3,.01),z("First lens"),s("l1ni","no-unit",1.6,1,3,.01),s("l1D1","mm",40,1,500,1),s("l1E1","mm",8,.5,200,.5),s("l1Dl","mm",30,1,500,1),s("l1Rl","mm",35,1,5e3,.1),ht("l1TypeL",["convex","planar","concave"]),s("l1Dr","mm",30,1,500,1),s("l1Rr","mm",50,1,5e3,.1),ht("l1TypeR",["convex","planar","concave"]),z("Second lens"),Ot("l2Active",!0),s("l2ni","no-unit",1.6,1,3,.01),s("l2D1","mm",40,1,500,1),s("l2E1","mm",8,.5,200,.5),s("l2Dl","mm",30,1,500,1),s("l2Rl","mm",35,1,5e3,.1),ht("l2TypeL",["convex","planar","concave"],1),s("l2Dr","mm",30,1,500,1),s("l2Rr","mm",50,1,5e3,.1),ht("l2TypeR",["convex","planar","concave"]),s("l2Px","mm",20,0,500,1),z("Third lens"),Ot("l3Active",!0),s("l3ni","no-unit",1.6,1,3,.01),s("l3D1","mm",40,1,500,1),s("l3E1","mm",8,.5,200,.5),s("l3Dl","mm",30,1,500,1),s("l3Rl","mm",35,1,5e3,.1),ht("l3TypeL",["convex","planar","concave"],2),s("l3Dr","mm",30,1,500,1),s("l3Rr","mm",50,1,5e3,.1),ht("l3TypeR",["convex","planar","concave"]),s("l3Px","mm",40,0,500,1),z("Simulation"),s("objectPx","mm",-50,-500,0,1),s("objectPy","mm",8,-500,500,1),s("ray1Angle","degree",0,-60,60,1),s("ray2Angle","degree",-2,-60,60,1),s("rayNb","rays",3,1,100,1),s("imagePx","mm",140,0,2e3,1),ht("simType",["oneRay","twoRays","parallel","object"])],paramSvg:{ne:"lens_profile.svg",l1ni:"lens_profile.svg",l1D1:"lens_profile.svg",l1E1:"lens_profile.svg",l1Dl:"lens_profile.svg",l1Rl:"lens_profile.svg",l1TypeL:"lens_profile.svg",l1Dr:"lens_profile.svg",l1Rr:"lens_profile.svg",l1TypeR:"lens_profile.svg",l2Active:"lens_multi.svg",l2ni:"lens_multi.svg",l2D1:"lens_profile.svg",l2E1:"lens_profile.svg",l2Dl:"lens_profile.svg",l2Rl:"lens_profile.svg",l2TypeL:"lens_profile.svg",l2Dr:"lens_profile.svg",l2Rr:"lens_profile.svg",l2TypeR:"lens_profile.svg",l2Px:"lens_multi.svg",l3Active:"lens_multi.svg",l3ni:"lens_multi.svg",l3D1:"lens_profile.svg",l3E1:"lens_profile.svg",l3Dl:"lens_profile.svg",l3Rl:"lens_profile.svg",l3TypeL:"lens_profile.svg",l3Dr:"lens_profile.svg",l3Rr:"lens_profile.svg",l3TypeR:"lens_profile.svg",l3Px:"lens_multi.svg",objectPx:"lens_simOneRay.svg",objectPy:"lens_simOneRay.svg",ray1Angle:"lens_simOneRay.svg",ray2Angle:"lens_simTwoRays.svg",rayNb:"lens_simParallel.svg",imagePx:"lens_simOneRay.svg",simType:"lens_simObject.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function Qo(o,t,i=""){const e=ft(eo.partName+i),n=O(),c=O(),g=O(),d=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const r=De();r.D1=t.l1D1,r.E1=t.l1E1,r.Rl=t.l1Rl,r.Dl=t.l1Dl,r.TypeL=t.l1TypeL,r.Rr=t.l1Rr,r.Dr=t.l1Dr,r.TypeR=t.l1TypeR,r.Drh=r.Dr/2,r.Dlh=r.Dl/2,r.E1pL=se(r.Rl,r.Dl,r.TypeL),r.E1pR=se(r.Rr,r.Dr,r.TypeR),r.E2=r.E1-r.E1pL-r.E1pR,r.E1h=r.E1/2,r.D1h=r.D1/2,r.x1=-r.E1h+r.E1pL,r.x2=r.E1h-r.E1pR;const l=De();l.D1=t.l2D1,l.E1=t.l2E1,l.Rl=t.l2Rl,l.Dl=t.l2Dl,l.TypeL=t.l2TypeL,l.Rr=t.l2Rr,l.Dr=t.l2Dr,l.TypeR=t.l2TypeR,l.Drh=l.Dr/2,l.Dlh=l.Dl/2,l.E1pL=se(l.Rl,l.Dl,l.TypeL),l.E1pR=se(l.Rr,l.Dr,l.TypeR),l.E2=l.E1-l.E1pL-l.E1pR,l.E1h=l.E1/2,l.D1h=l.D1/2,l.x1=-l.E1h+l.E1pL,l.x2=l.E1h-l.E1pR;const f=De();f.D1=t.l3D1,f.E1=t.l3E1,f.Rl=t.l3Rl,f.Dl=t.l3Dl,f.TypeL=t.l3TypeL,f.Rr=t.l3Rr,f.Dr=t.l3Dr,f.TypeR=t.l3TypeR,f.Drh=f.Dr/2,f.Dlh=f.Dl/2,f.E1pL=se(f.Rl,f.Dl,f.TypeL),f.E1pR=se(f.Rr,f.Dr,f.TypeR),f.E2=f.E1-f.E1pL-f.E1pR,f.E1h=f.E1/2,f.D1h=f.D1/2,f.x1=-f.E1h+f.E1pL,f.x2=f.E1h-f.E1pR,ve(r,"lens-1"),ve(l,"lens-2"),ve(f,"lens-3"),e.logstr+=me(r,"lens-1"),e.logstr+=me(l,"lens-2"),e.logstr+=me(f,"lens-3");const h=Vt(r,0,1,!1);ke(h,r,0),n.addMainO(h);const S=Vt(l,t.l2Px,1,!1);ke(S,l,t.l2Px),t.l2Active?n.addMainO(S):n.addSecond(S);const A=Vt(f,t.l3Px,1,!1);ke(A,f,t.l3Px),t.l3Active?n.addMainO(A):n.addSecond(A);const u=X(t.objectPx,t.objectPy,"green");u.addSegStrokeA(t.objectPx,0),n.addDynamics(u);const x=X(t.imagePx,-r.D1h,"green");x.addSegStrokeA(t.imagePx,r.D1h),n.addDynamics(x);const $=1.2*t.imagePx-t.objectPx;n.addVector(ie(0,$,xt(t.objectPx,0)));const D=X(t.objectPx,0,"grey").addSegStrokeR($,0);n.addDynamics(D);const J={E1:r.E1,Dl:r.Dl,Rl:r.Rl,TypeL:r.TypeL,Dr:r.Dr,Rr:r.Rr,TypeR:r.TypeR,ni:t.l1ni,PosX:0},m={E1:l.E1,Dl:l.Dl,Rl:l.Rl,TypeL:l.TypeL,Dr:l.Dr,Rr:l.Rr,TypeR:l.TypeR,ni:t.l2ni,PosX:t.l2Px},_={E1:f.E1,Dl:f.Dl,Rl:f.Rl,TypeL:f.TypeL,Dr:f.Dr,Rr:f.Rr,TypeR:f.TypeR,ni:t.l3ni,PosX:t.l3Px},M=[J];t.l2Active&&M.push(m),t.l3Active&&M.push(_);const[B,v]=pe(t.objectPx,t.objectPy,t.ray1Angle,t.ray2Angle,t.rayNb,t.simType,t.ne,M,t.imagePx);for(const L of B)n.addDynamics(L);e.logstr+=v,c.addMainO(Vt(r,0,1,!0).rotate(0,0,Math.PI/2)),c.addSecond(Vt(r,0,-1,!0).rotate(0,0,Math.PI/2)),g.addMainO(Vt(l,0,1,!0).rotate(0,0,Math.PI/2)),g.addSecond(Vt(l,0,-1,!0).rotate(0,0,Math.PI/2)),d.addMainO(Vt(f,0,1,!0).rotate(0,0,Math.PI/2)),d.addSecond(Vt(f,0,-1,!0).rotate(0,0,Math.PI/2)),e.fig={faceLensSim:n,faceLens1:c,faceLens2:g,faceLens3:d};const C=e.partName;e.vol={extrudes:[{outName:`subpax_${C}_lens1`,face:`${C}_faceLens1`,extrudeMethod:et.eRotate,rotate:[0,0,0],translate:[0,0,0]},{outName:`subpax_${C}_lens2`,face:`${C}_faceLens2`,extrudeMethod:et.eRotate,rotate:[0,0,0],translate:[0,0,t.l2Px]},{outName:`subpax_${C}_lens3`,face:`${C}_faceLens3`,extrudeMethod:et.eRotate,rotate:[0,0,0],translate:[0,0,t.l3Px]}],volumes:[{outName:`pax_${C}`,boolMethod:Rt.eUnion,inList:[`subpax_${C}_lens1`,`subpax_${C}_lens2`,`subpax_${C}_lens3`]}]};const y=bt(Kt.pDef);y.setVal("D1",t.l1D1),y.setVal("E1",t.l1E1),y.setVal("Dl",t.l1Dl),y.setVal("Rl",t.l1Rl),y.setVal("TypeL",t.l1TypeL),y.setVal("Dr",t.l1Dr),y.setVal("Rr",t.l1Rr),y.setVal("TypeR",t.l1TypeR),y.setVal("ni",t.l1ni),y.setVal("ne",t.ne);const E=Kt.pGeom(0,y.getParamVal(),y.getSuffix());vt(E),e.logstr+=Mt(E.logstr,y.getPartNameSuffix());const k=bt(Kt.pDef);k.setVal("D1",t.l2D1),k.setVal("E1",t.l2E1),k.setVal("Dl",t.l2Dl),k.setVal("Rl",t.l2Rl),k.setVal("TypeL",t.l2TypeL),k.setVal("Dr",t.l2Dr),k.setVal("Rr",t.l2Rr),k.setVal("TypeR",t.l2TypeR),k.setVal("ni",t.l2ni),k.setVal("ne",t.ne);const N=Kt.pGeom(0,k.getParamVal(),k.getSuffix());vt(N),e.logstr+=Mt(N.logstr,k.getPartNameSuffix());const T=bt(Kt.pDef);T.setVal("D1",t.l3D1),T.setVal("E1",t.l3E1),T.setVal("Dl",t.l3Dl),T.setVal("Rl",t.l3Rl),T.setVal("TypeL",t.l3TypeL),T.setVal("Dr",t.l3Dr),T.setVal("Rr",t.l3Rr),T.setVal("TypeR",t.l3TypeR),T.setVal("ni",t.l3ni),T.setVal("ne",t.ne);const w=Kt.pGeom(0,T.getParamVal(),T.getSuffix());vt(E),e.logstr+=Mt(w.logstr,T.getPartNameSuffix()),e.sub={lens_1:{partName:y.getPartName(),dparam:y.getDesignParamList(),orientation:[0,0,0],position:[0,0,0]},lens_2:{partName:k.getPartName(),dparam:k.getDesignParamList(),orientation:[0,0,0],position:[0,0,0]},lens_3:{partName:T.getPartName(),dparam:T.getDesignParamList(),orientation:[0,0,0],position:[0,0,0]}},e.logstr+=`lens_x3 drawn successfully!
`,e.calcErr=!1}catch(r){e.logstr+=r,console.log(r)}return e}var Yo={pTitle:"Lens_x3",pDescription:"Three spherical lens",pDef:eo,pGeom:Qo},oo={partName:"pulley",params:[s("zn","peg",100,3,300,1),s("pim","mm",2,.5,20,.05),z("Profile details"),s("bw","mm",.45,.1,3,.01),s("nw","mm",.9,.1,3,.01),s("pegR","mm",.55,.05,2,.01),s("ha","degree",5,-40,40,1),s("ra","mm",0,0,3,.1),z("Inner hollow"),s("rw","mm",2,.5,10,.1),z("Rim"),s("rimPlus","mm",1.5,-2,4,.5),Ot("rimLeft",!0),Ot("rimRight",!0),z("Widths"),s("wheelW","mm",7,1,10,.1),s("rimW","mm",1.2,.5,5,.1)],paramSvg:{zn:"pulley_peg.svg",pim:"pulley_peg.svg",bw:"pulley_peg.svg",nw:"pulley_peg.svg",pegR:"pulley_peg.svg",ha:"pulley_peg.svg",ra:"pulley_peg.svg",rw:"pulley_peg.svg",rimPlus:"pulley_rim.svg",rimLeft:"pulley_rim.svg",rimRight:"pulley_rim.svg",wheelW:"pulley_rim.svg",rimW:"pulley_rim.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function po(o,t,i=""){const e=ft(oo.partName+i),n=O(),c=O(),g=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const r=t.zn*t.pim/Math.PI/2,l=r-t.bw,f=l-t.nw,h=l-t.rw,S=2*Math.PI/t.zn,A=f+t.pegR,u=Math.PI/2-p(t.ha),x=t.pegR,[$,D]=Yt(A,u,x),[J,m]=Pt(x,A,$),[_,M]=Pt($,x,A),B=J+Math.PI/2,[v,C,y]=je(B,$,l),E=Math.min(Math.abs(v),Math.abs(C)),[k,N]=Pt($,E,l),T=Math.sign(Qt(B))*k,L=2*(_-T),F=S-L,P=l+t.rimPlus,q=t.wheelW/2;if(e.logstr+=D+m+M+y+N,$>l)throw`err332: lAD ${$} is larger than R2 ${l}`;if(F<=0)throw`err115: apa ${F} is negative`;if(L<=0)throw`err116: apd ${L} is negative`;if(h<=0)throw`err123: R4 ${h} is negative`;if(f<=h)throw`err126: R3 ${f} is too small compare to R4 ${h}`;if(P<=h)throw`err129: rimR ${P} smaller than R4 ${h}`;e.logstr+=`R1: ${a(r)}  D1: ${a(2*r)} mm
`,e.logstr+=`R2: ${a(l)}  D2: ${a(2*l)} mm
`,e.logstr+=`R3: ${a(f)}  D3: ${a(2*f)} mm
`,e.logstr+=`R4: ${a(h)}  D4: ${a(2*h)} mm
`,e.logstr+=`pitch length at R2: ${a(S*l)} mm
`,e.logstr+=`addendum length: ${a(F*l)} mm
`,e.logstr+=`dedendum length: ${a(L*l)} mm
`;const V=X(l,0);for(let b=0;b<t.zn;b++){const U=b*S,it=U+F+L/2;V.addPointAP(U+F/2,l).addPointAP(U+F,l).addSegArc2(),V.addCornerRounded(t.ra),V.addSegStrokeAP(it-_,$),V.addPointAP(it,f).addPointAP(it+_,$).addSegArc2(),V.addSegStrokeAP(U+S,l),V.addCornerRounded(t.ra)}n.addMainOI([V,G(0,0,h)]),n.addSecond(G(0,0,r)),n.addSecond(G(0,0,l)),n.addSecond(G(0,0,f)),c.addMainOI([G(0,0,P),G(0,0,h)]),c.addSecond(V),g.addMainO(j(-q,-l,t.wheelW,2*l)),g.addMainO(j(-q-t.rimW,-P,t.rimW,2*P)),g.addMainO(j(q,-P,t.rimW,2*P)),e.fig={facePulleyProfile:n,facePulleyRim:c,facePulleyWidth:g};const R=e.partName,W=[];t.rimLeft&&W.push(`subpax_${R}_rim1`),W.push(`subpax_${R}_wheel`),t.rimRight&&W.push(`subpax_${R}_rim2`),e.vol={extrudes:[{outName:`subpax_${R}_wheel`,face:`${R}_facePulleyProfile`,extrudeMethod:et.eLinearOrtho,length:t.wheelW,rotate:[0,0,0],translate:[0,0,t.rimW]},{outName:`subpax_${R}_rim1`,face:`${R}_facePulleyRim`,extrudeMethod:et.eLinearOrtho,length:t.rimW,rotate:[0,0,0],translate:[0,0,0]},{outName:`subpax_${R}_rim2`,face:`${R}_facePulleyRim`,extrudeMethod:et.eLinearOrtho,length:t.rimW,rotate:[0,0,0],translate:[0,0,t.wheelW+t.rimW]}],volumes:[{outName:`pax_${R}`,boolMethod:Rt.eUnion,inList:W}]},e.sub={},e.logstr+=`pulley drawn successfully!
`,e.calcErr=!1}catch(d){e.logstr+=d,console.log(d)}return e}var tn={pTitle:"Pulley",pDescription:"A pulley for belt with peg",pDef:oo,pGeom:po},no={partName:"rail",params:[s("W1","mm",200,2,400,1),s("W2","mm",10,.5,40,.5),s("W3","mm",100,1,200,1),z("Heights"),s("H1","mm",6,1,30,1),s("H2","mm",10,1,50,1),s("H3","mm",100,1,500,1),s("H4","mm",10,1,50,1),s("H5","mm",30,1,100,1),s("H6","mm",10,1,100,1),z("Corners"),s("R1","mm",3,0,30,1),z("Depth"),s("L1","mm",100,1,1e3,1)],paramSvg:{W1:"rail_profile.svg",W2:"rail_profile.svg",W3:"rail_profile.svg",H1:"rail_profile.svg",H2:"rail_profile.svg",H3:"rail_profile.svg",H4:"rail_profile.svg",H5:"rail_profile.svg",H6:"rail_profile.svg",R1:"rail_profile.svg",L1:"rail_profile.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function en(o,t,i=""){const e=ft(no.partName+i),n=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const c=t.W1/2,g=t.W2/2,d=t.W3/2,r=t.H1+t.H2+t.H3+t.H4+t.H5+t.H6;if(t.W2>=t.W1)throw`err210: W2 ${t.W2} is larger than W1 ${t.W1}`;if(t.W2>=t.W3)throw`err213: W2 ${t.W2} is larger than W3 ${t.W3}`;e.logstr+=`total height: ${a(r)} mm
`;const l=X(c,0).addCornerRounded(t.R1).addSegStrokeR(0,t.H1).addCornerRounded(t.R1).addSegStrokeR(g-c,t.H2).addCornerRounded(t.R1).addSegStrokeR(0,t.H3).addCornerRounded(t.R1).addSegStrokeR(d-g,t.H4).addCornerRounded(t.R1).addSegStrokeR(0,t.H5).addCornerRounded(t.R1).addPointA(0,r).addPointA(-d,r-t.H6).addSegArc2().addCornerRounded(t.R1).addSegStrokeR(0,-t.H5).addCornerRounded(t.R1).addSegStrokeR(d-g,-t.H4).addCornerRounded(t.R1).addSegStrokeR(0,-t.H3).addCornerRounded(t.R1).addSegStrokeR(g-c,-t.H2).addCornerRounded(t.R1).addSegStrokeR(0,-t.H1).addCornerRounded(t.R1).closeSegStroke();n.addMainO(l),e.fig={faceRail:n};const f=e.partName;e.vol={extrudes:[{outName:`subpax_${f}`,face:`${f}_faceRail`,extrudeMethod:et.eLinearOrtho,length:t.L1,rotate:[0,0,0],translate:[0,0,0]}],volumes:[{outName:`pax_${f}`,boolMethod:Rt.eIdentity,inList:[`subpax_${f}`]}]},e.sub={},e.logstr+=`rail drawn successfully!
`,e.calcErr=!1}catch(c){e.logstr+=c,console.log(c)}return e}var on={pTitle:"rail",pDescription:"A rail for train",pDef:no,pGeom:en},so={partName:"codeExample1",params:[s("L2","mm",40,5,100,1),s("a3","degree",60,-30,120,1),s("L3","mm",20,5,100,1),s("a4","degree",45,5,80,1),s("L4","mm",40,5,100,1),s("R34","mm",15,5,100,1),s("a5","degree",70,30,150,1),s("L5","mm",20,5,100,1),z("Corner"),s("R4","mm",2,0,20,1),z("Thickness"),s("T1","mm",5,1,20,1)],paramSvg:{L2:"codeExample1_contour.svg",a3:"codeExample1_contour.svg",L3:"codeExample1_contour.svg",a4:"codeExample1_contour.svg",L4:"codeExample1_contour.svg",R34:"codeExample1_contour.svg",a5:"codeExample1_contour.svg",L5:"codeExample1_contour.svg",R4:"codeExample1_contour.svg",T1:"codeExample1_contour.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function nn(o,t,i=""){const e=ft(so.partName+i),n=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const c=p(t.a3),g=p(t.a4),d=p(t.a5),r=c+g+d;if(t.L2<t.L3)throw`err639: L2 ${a(t.L2)} is smaller than L3 ${a(t.L3)}`;e.logstr+=`sum of angles: ${a(Q(r))} degree`;const l=X(0,0).addSegStrokeR(t.L2,0).addSegStrokeRP(c,t.L3).addPointAP(g,t.L4).addSegArc(t.R34,!0,!0).addCornerRounded(t.R4).addPointA(0,t.L5).addSegArc3(d,!1).closeSegStroke();n.addMainO(l),e.fig={faceExample1:n};const f=e.partName;e.vol={extrudes:[{outName:`subpax_${f}_example1`,face:`${f}_faceExample1`,extrudeMethod:et.eLinearOrtho,length:t.T1,rotate:[0,0,0],translate:[0,0,0]}],volumes:[{outName:`pax_${f}`,boolMethod:Rt.eIdentity,inList:[`subpax_${f}_example1`]}]},e.sub={},e.logstr+=`codeExample1 drawn successfully!
`,e.calcErr=!1}catch(c){e.logstr+=c,console.log(c)}return e}var sn={pTitle:"codeExample1",pDescription:"Showing the features of contour",pDef:so,pGeom:nn},io={partName:"demoTriangule",params:[s("lAB","mm",60,0,200,1),s("lBC","mm",40,0,200,1),s("lAC","mm",35,0,200,1),s("aCAB","degree",35,-180,180,1),s("aABC","degree",45,-180,180,1),z("Start"),s("Ax","mm",50,-1e3,1e3,1),s("Ay","mm",50,-1e3,1e3,1),s("aAB","degree",10,-190,190,1),z("Thickness"),s("T1","mm",5,1,20,1)],paramSvg:{lAB:"demoTriangule_overview.svg",lBC:"demoTriangule_triangle.svg",lAC:"demoTriangule_triangle.svg",aCAB:"demoTriangule_anglePotentialError.svg",aABC:"demoTriangule_strokeAngle.svg",Ax:"demoTriangule_start.svg",Ay:"demoTriangule_start.svg",aAB:"demoTriangule_start.svg",T1:"demoTriangule_triangle.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function rn(o,t,i=""){const e=ft(io.partName+i),n=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const c=p(t.aAB),g=p(t.aCAB),d=p(t.aABC),[r,l,f]=Ve(g,t.lAB,d),[h,S]=re(g,d),[A,u]=Yt(t.lAC,g,t.lAB),[x,$]=Pt(t.lAC,t.lAB,A),D=Math.sign(g)*x,[J,m]=re(g,D);e.logstr+=f+S+u+$+m;const _=xo(g,t.lAB,t.lBC),[M,B,v]=_.slice(0,3),[C,y,E]=_.slice(3,6);e.logstr+=_[6];const[k,N]=re(B,v),[T,w]=re(y,E),[L,F,P,q]=_o(t.lAB,t.lBC,t.lAC);e.logstr+=N+w+q;const V=300;if(t.lAB<0)throw`err639: lAB ${a(t.lAB)} is negative`;e.logstr+=`triangle-1: aA ${a(Q(g))}, lAB ${a(t.lAB)}, aB ${a(Q(d))}
`,e.logstr+=`triangle-1: lBC ${a(r)} aC ${a(Q(h))}, lCA ${a(l)}
`,e.logstr+=`triangle-2: lAC ${a(t.lAC)}, aA ${a(Q(g))}, lAB ${a(t.lAB)}
`,e.logstr+=`triangle-2: aB ${a(Q(J))}, lBC ${a(A)}, aC ${a(Q(D))}
`,e.logstr+=`triangle-3: aA ${a(Q(g))}, lAB ${a(t.lAB)}, lBC ${a(t.lBC)}
`,e.logstr+=`triangle-31: lAC1 ${a(M)} aB1 ${a(Q(v))}, aC1 ${a(Q(k))}
`,e.logstr+=`triangle-32: lAC2 ${a(C)} aB2 ${a(Q(E))}, aC2 ${a(Q(T))}
`,e.logstr+=`triangle-4: lAB ${a(t.lAB)}, lBC ${a(t.lBC)}, lAC ${a(t.lAC)}
`,e.logstr+=`triangle-4: aA ${a(Q(L))}, aB ${a(Q(F))}, aC ${a(Q(P))}
`;const R=X(t.Ax,t.Ay).addSegStrokeRP(c,t.lAB).addSegStrokeRP(c+Math.PI+d,r).closeSegStroke();n.addMainO(R);const[W,b]=Pe(t.Ax,t.Ay,c-g,l);n.addSecond(G(W,b,l)),n.addSecond(G(W,b,r));const U=X(t.Ax+V,t.Ay).addSegStrokeRP(c,t.lAB).addSegStrokeRP(c+Math.PI+J,A).closeSegStroke();n.addMainO(U),n.addSecond(G(t.Ax+V,t.Ay,t.lAC));const it=X(t.Ax+V,t.Ay-V).addSegStrokeRP(c,t.lAB).addSegStrokeRP(c+Math.PI+v,t.lBC).closeSegStroke();n.addMainO(it);const lt=X(t.Ax+V,t.Ay-V).addSegStrokeRP(c,t.lAB).addSegStrokeRP(c+Math.PI+E,t.lBC).closeSegStroke();n.addSecond(lt);const[tt,ot]=Pe(t.Ax+V,t.Ay-V,c,t.lAB);n.addSecond(G(tt,ot,t.lBC));const rt=X(t.Ax,t.Ay-V).addSegStrokeRP(c,t.lAB).addSegStrokeRP(c+Math.PI+F,t.lBC).closeSegStroke();n.addMainO(rt);const gt=X(t.Ax,t.Ay-V).addSegStrokeRP(c,t.lAB).addSegStrokeRP(c+Math.PI-F,t.lBC).closeSegStroke();n.addSecond(gt),n.addSecond(G(t.Ax,t.Ay-V,t.lAC)),e.fig={faceTriangles:n};const st=e.partName;e.vol={extrudes:[{outName:`subpax_${st}_triangles`,face:`${st}_faceTriangles`,extrudeMethod:et.eLinearOrtho,length:t.T1,rotate:[0,0,0],translate:[0,0,0]}],volumes:[{outName:`pax_${st}`,boolMethod:Rt.eIdentity,inList:[`subpax_${st}_triangles`]}]},e.sub={},e.logstr+=`demoTriangule drawn successfully!
`,e.calcErr=!1}catch(c){e.logstr+=c,console.log(c)}return e}var cn={pTitle:"demoTriangule",pDescription:"demonstrate the Triangule library",pDef:io,pGeom:rn},ro={partName:"demoSheetFold",params:[s("W","mm",80,10,200,1),s("L1","mm",60,10,200,1),s("L2","mm",35,10,200,1),z("Fold"),s("Ja","degree",60,-240,240,1),s("Jr","mm",10,0,20,1),s("Jn","%",50,0,100,1),z("Thickness"),s("T","mm",10,1,20,1),s("jMark","mm",1,0,20,.1),s("R1","mm",10,0,30,1),s("R2","mm",10,0,30,1)],paramSvg:{W:"demoSheetFold_cut.svg",L1:"demoSheetFold_cut.svg",L2:"demoSheetFold_cut.svg",Ja:"demoSheetFold_cut.svg",Jr:"demoSheetFold_cut.svg",Jn:"demoSheetFold_cut.svg",T:"demoSheetFold_cut.svg",R1:"demoSheetFold_cut.svg",R2:"demoSheetFold_cut.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function dn(o,t,i=""){const e=ft(ro.partName+i),n=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const c=t.Jn/100,g=t.Jr-t.T*c,d=t.Jr+t.T*(1-c),r=p(t.Ja),l=r*t.Jr,f=r*g,h=r*d;if(t.L1>t.W)throw`err633: L1 ${t.L1} is bigger than W ${t.W} and nobody cares!`;e.logstr+=`junction: radius neutral ${a(t.Jr)}, intern ${a(g)}, extern ${a(d)}
`,e.logstr+=`junction: neutral arc ${a(l)}, intern arc ${a(f)}, extern arc ${a(h)}
`;const S=K(0,0).addCornerRounded(t.R1).addSegStrokeR(t.L1,0).startJunction("J1",I.eA,H.eABLeft).addSegStrokeR(0,t.W).addSegStrokeR(-t.L1,0).addCornerRounded(t.R1).closeSegStroke(),A=Y([S]);n.addMainO(ge(S));const u=X(t.L1,0).addSegStrokeR(l,0).addSegStrokeR(0,t.W).addSegStrokeR(-l,0).closeSegStroke();n.addMainO(u);const x=K(t.L1+l,0).addSegStrokeR(t.L2,t.W/2).addCornerRounded(t.R2).addSegStrokeR(-t.L2,t.W/2).startJunction("J1",I.eB,H.eABRight).closeSegStroke(),$=Y([x]);n.addMainO(ge(x));const D=qt([A,$],{J1:{angle:r,radius:t.Jr,neutral:c,mark:t.jMark}},[{x1:0,y1:0,a1:0,l1:t.L1,ante:[],post:["J1",t.L2]}],t.T,e.partName);e.fig={faceCut:n,facet1:ce(A),facet3:ce($)};const J=D.makeFigures();for(const m of Object.keys(J))e.fig[m]=J[m];e.vol=D.makeVolume(),e.sub={},e.logstr+=`demoSheetFold drawn successfully!
`,e.calcErr=!1}catch(c){e.logstr+=c,console.log(c)}return e}var ln={pTitle:"demoSheetFold",pDescription:"demonstrate the SheetFold library",pDef:ro,pGeom:dn},co={partName:"demoSheetFold2",params:[s("L1","mm",100,10,300,1),s("W1","mm",200,10,500,1),s("J1","degree",60,-200,200,1),s("L2","mm",100,10,300,1),s("A2","degree",60,1,179,1),s("J2","degree",60,-200,200,1),s("L3","mm",100,10,300,1),s("A3","degree",60,1,179,1),s("J3","degree",60,-200,200,1),s("L4","mm",100,10,300,1),s("A4","degree",60,1,179,1),s("J4","degree",60,-200,200,1),s("W5","mm",100,10,300,1),z("Thickness and fold"),s("Th","mm",10,1,20,1),s("Jradius","mm",20,1,50,1),s("Jneutral","%",50,0,100,1),s("Jmark","mm",1,0,20,.1)],paramSvg:{L1:"demoSF2_patron.svg",W1:"demoSF2_patron.svg",J1:"demoSF2_patron.svg",L2:"demoSF2_patron.svg",A2:"demoSF2_patron.svg",J2:"demoSF2_patron.svg",L3:"demoSF2_patron.svg",A3:"demoSF2_patron.svg",J3:"demoSF2_patron.svg",L4:"demoSF2_patron.svg",A4:"demoSF2_patron.svg",J4:"demoSF2_patron.svg",W5:"demoSF2_patron.svg",Th:"demoSF2_patron.svg",Jradius:"demoSF2_patron.svg",Jneutral:"demoSF2_patron.svg",Jmark:"demoSF2_patron.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function an(o,t,i=""){const e=ft(co.partName+i);e.logstr+=`${e.partName} simTime: ${o}
`;try{const n=t.Jneutral/100,c=t.Jradius,g=t.Jmark,d=c-t.Th*n,r=c+t.Th*(1-n);if(c<t.Th)throw`err107: Jradius ${c} is smaller than Th ${t.Th}`;e.logstr+=`junction: radius neutral ${a(c)}, intern ${a(d)}, extern ${a(r)}
`;const l=K(0,0).addSegStrokeR(t.W1,0).startJunction("J1",I.eA,H.eABLeft).addSegStrokeR(0,t.L1).addSegStrokeR(-t.W1,0).closeSegStroke(),f=Y([l]),h=K(0,0).startJunction("J1",I.eB,H.eABRight).addSegStrokeA(t.L1,0).addSegStrokeAP(p(t.A2),t.L2).startJunction("J2",I.eB,H.eABRight).closeSegStroke(),S=Y([h]),A=K(0,0).startJunction("J3",I.eA,H.eABLeft).addSegStrokeA(t.L3,0).addSegStrokeAP(p(t.A3),t.L2).startJunction("J2",I.eA,H.eABLeft).closeSegStroke(),u=Y([A]),x=K(0,0).startJunction("J3",I.eB,H.eABRight).addSegStrokeA(t.L3,0).addSegStrokeAP(p(t.A4),t.L4).startJunction("J4",I.eA,H.eABLeft).closeSegStroke(),$=Y([x]),D=K(0,0).addSegStrokeR(t.W5,0).addSegStrokeR(0,t.L4).addSegStrokeR(-t.W5,0).startJunction("J4",I.eB,H.eABRight).closeSegStroke(),J=Y([D]),[m,_]=Yt(t.L1,p(t.A2),t.L2),[M,B]=Yt(t.L2,p(t.A3),t.L3),[v,C]=Yt(t.L3,p(t.A4),t.L4);e.logstr+=_+B+C;const y=qt([f,S,u,$,J],{J1:{angle:p(t.J1),radius:c,neutral:n,mark:g},J2:{angle:p(t.J2),radius:c,neutral:n,mark:g},J3:{angle:p(t.J3),radius:c,neutral:n,mark:g},J4:{angle:p(t.J4),radius:c,neutral:n,mark:g}},[{x1:0,y1:0,a1:0,l1:t.W1,ante:[],post:["J1",m,"J2",1,"J3",v,"J4",t.W5]},{x1:0,y1:4*t.L1,a1:0,l1:t.W1,ante:[],post:["J1",1,"J2",M,"J3",1,"J4",t.W5]}],t.Th,e.partName),E=y.makeFigures();for(const k of Object.keys(E))e.fig[k]=E[k];e.vol=y.makeVolume(),e.sub={},e.logstr+=`demoSheetFold2 drawn successfully!
`,e.calcErr=!1}catch(n){e.logstr+=n,console.log(n)}return e}var gn={pTitle:"demoSheetFold2",pDescription:"demonstrate SheetFold with multiple stages",pDef:co,pGeom:an},lo={partName:"armEnd",params:[s("W2A","mm",60,1,500,1),s("W2B","mm",60,1,500,1),Ot("eqWAB",!0),z("Face"),s("L1","mm",50,1,500,1),s("L2","mm",50,1,500,1),s("D1","mm",40,1,200,1),s("S1","mm",10,1,200,1),z("Hollow"),s("D2","mm",20,0,200,1),s("D3A","mm",30,0,200,1),s("D3B","mm",30,0,200,1),z("Thickness and corners"),s("T1","mm",3,.5,10,.25),s("Jmark","mm",1,0,20,.1),s("Jradius","mm",5,0,50,1),s("Jneutral","%",50,0,100,1)],paramSvg:{W2A:"armEnd_section.svg",W2B:"armEnd_section.svg",eqWAB:"armEnd_section.svg",L1:"armEnd_face.svg",L2:"armEnd_face.svg",D1:"armEnd_face.svg",S1:"armEnd_face.svg",D2:"armEnd_face.svg",D3A:"armEnd_face.svg",D3B:"armEnd_side.svg",T1:"armEnd_section.svg",Jmark:"armEnd_section.svg",Jradius:"armEnd_section.svg",Jneutral:"armEnd_section.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function fn(o,t,i=""){const e=ft(lo.partName+i),n=O(),c=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{let r=function(tt){const ot=K(-m,0).addSegStrokeR($,0);return tt.length>0&&ot.startJunction(tt[0],I.eA,H.eABLeft),ot.addSegStrokeA(m,t.L1).addSegStrokeAifBig(k,t.L1+t.L2+N,.5,!1).addPointA(0,t.L1+t.L2+v).addPointA(-k,t.L1+t.L2+N).addSegArc2().addSegStrokeAifBig(-m,t.L1,.5,!0),tt.length>1&&ot.startJunction(tt[1],I.eB,H.eABRight),ot.closeSegStroke(),ot},l=function(tt){const ot=K(-_,0).addSegStrokeR(D,0);return tt.length>0&&ot.startJunction(tt[0],I.eA,H.eABLeft),ot.addSegStrokeR(0,t.L1).addSegStrokeR(-D,0),tt.length>1&&ot.startJunction(tt[1],I.eB,H.eABRight),ot.closeSegStroke(),ot};var g=r,d=l;const f=t.Jneutral/100,h=t.D1/2,S=t.D2/2,A=t.D3A/2;let u=t.D3B/2;const x=t.Jradius+t.T1*(1-f),$=t.W2A-2*x;let D=t.W2B-2*x;t.eqWAB&&(u=A,D=$);const J=Math.PI/2,m=$/2,_=D/2,M=Math.sqrt(t.L2**2+m**2),B=Math.atan2(m,t.L2),v=h+t.S1;let C=0;const y=.01;if(v>M+y)throw`err123: lDiag ${a(M)} too small compare to D1 ${t.D1} and S1 ${t.S1}`;v<M-y&&(C=Math.acos(v/M));const E=-Math.PI/2+B+C,k=v*Math.cos(E),N=v*Math.sin(E),T=(t.L2-h)/2;if($<t.D3A)throw`err118: W1A ${$} too small compare to D3A ${t.D3A}`;if(t.L1<t.D3A)throw`err119: param.L1 ${t.L1} too small compare to D3A ${t.D3A}`;if(D<t.D3B)throw`err121: W1B ${D} too small compare to D3B ${t.D3B}`;if(t.L1<t.D3B)throw`err122: param.L1 ${t.L1} too small compare to D3B ${t.D3B}`;if(t.L2<h+2*S)throw`err124: L2 ${t.L2} too small compare to D1 ${t.D1} and D2 ${t.D2}`;e.logstr+=`W1A ${a($)}, W1B ${a(D)}
`;const w=[];A>0&&w.push(G(0,t.L1/2,A)),h>0&&w.push(G(0,t.L1+t.L2,h)),S>0&&w.push(G(0,t.L1+T,S));const L=[];u>0&&L.push(G(0,t.L1/2,u));const F=r(["J1"]),P=Y([F,...w]),q=l(["J2","J1"]),V=Y([q,...L]),R=r(["J3","J2"]),W=Y([R,...w]),b=l(["J4","J3"]),U=Y([b,...L]),it=qt([P,V,W,U],{J1:{angle:J,radius:t.Jradius,neutral:f,mark:t.Jmark},J2:{angle:J,radius:t.Jradius,neutral:f,mark:t.Jmark},J3:{angle:J,radius:t.Jradius,neutral:f,mark:t.Jmark},J4:{angle:J,radius:t.Jradius,neutral:f,mark:t.Jmark}},[{x1:0,y1:0,a1:0,l1:$,ante:[],post:["J1",D,"J2",$,"J3",D,"J4"]}],t.T1,e.partName);n.mergeFigure(ce(P)),n.addSecond(j(-t.W2A/2,0,(t.W2A-$)/2,t.L1)),n.addSecond(j($/2,0,(t.W2A-$)/2,t.L1)),c.mergeFigure(ce(V)),c.addSecond(j(-t.W2B/2,0,(t.W2B-D)/2,t.L1)),c.addSecond(j(D/2,0,(t.W2B-D)/2,t.L1)),c.addMainO(j(-t.W2B/2,0,t.T1,t.L1+t.L2+h+t.S1)),c.addMainO(j(t.W2B/2-t.T1,0,t.T1,t.L1+t.L2+h+t.S1)),e.fig={faceSide:n,faceTop:c};const lt=it.makeFigures();for(const tt of Object.keys(lt))e.fig[tt]=lt[tt];e.vol=it.makeVolume(),e.sub={},e.logstr+=`armEnd drawn successfully!
`,e.calcErr=!1}catch(r){e.logstr+=r,console.log(r)}return e}var jt={pTitle:"armEnd",pDescription:"robotic arm extremity",pDef:lo,pGeom:fn},ao={partName:"armAxis",params:[s("D1","mm",20,1,200,1),s("T1","mm",3,.5,10,.25),s("L1","mm",50,1,500,1),z("Hollow"),s("D2","mm",10,0,200,1),s("D3","mm",20,0,200,1)],paramSvg:{D1:"armAxis_section.svg",T1:"armAxis_section.svg",L1:"armAxis_length.svg",D2:"armAxis_length.svg",D3:"armAxis_section.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function un(o,t,i=""){const e=ft(ao.partName+i),n=O(),c=O(),g=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const d=t.D1/2,r=d-t.T1,l=t.D2/2,f=t.D3/2;if(r<=0)throw`err102: T1 ${t.T1} too large compare to D1 ${t.D1}`;if(t.D1<t.D2)throw`err105: D1 ${t.D1} too small compare to D2 ${t.D2}`;if(t.L1<t.D3)throw`err108: param.L1 ${t.L1} too small compare to D3 ${t.D3}`;if(t.D1<f)throw`err111: D1 ${t.D1} too small compare to D3 ${t.D3}`;e.logstr+=`D1 ${a(t.D1)}, R1 ${a(d)}
`,e.logstr+=`D1b ${a(2*r)}, R1b ${a(r)}
`,n.addMainOI([G(0,0,d),G(0,0,r)]),n.addSecond(j(1,-l,2*d,2*l)),n.addSecond(j(-d-f,-t.D1,2*f,2*t.D1)),c.addMainO(G(0,0,l)),c.addSecond(j(-t.L1/2,-d,t.L1,2*d)),c.addSecond(j(-t.L1/2,-r,t.L1,2*r)),g.addMainO(G(0,0,f)),g.addSecond(j(-t.L1/2,0,t.L1,2*d)),g.addSecond(j(-t.L1/2,t.T1,t.L1,2*r)),e.fig={faceAxis:n,faceHoleS:c,faceHoleL:g};const h=e.partName;e.vol={extrudes:[{outName:`subpax_${h}_Axis`,face:`${h}_faceAxis`,extrudeMethod:et.eLinearOrtho,length:t.L1,rotate:[0,0,0],translate:[0,0,0]},{outName:`subpax_${h}_HoleS`,face:`${h}_faceHoleS`,extrudeMethod:et.eLinearOrtho,length:2*t.D1,rotate:[0,Math.PI/2,0],translate:[0,0,t.L1/2]},{outName:`subpax_${h}_HoleL`,face:`${h}_faceHoleL`,extrudeMethod:et.eLinearOrtho,length:2*t.D1,rotate:[-Math.PI/2,0,0],translate:[-d,-t.D1,t.L1/2]}],volumes:[{outName:`pax_${h}`,boolMethod:Rt.eSubstraction,inList:[`subpax_${h}_Axis`,`subpax_${h}_HoleS`,`subpax_${h}_HoleL`]}]},e.sub={},e.logstr+=`armAxis drawn successfully!
`,e.calcErr=!1}catch(d){e.logstr+=d,console.log(d)}return e}var Je={pTitle:"armAxis",pDescription:"axis of robotic arm joint",pDef:ao,pGeom:un},go={partName:"armJoint",params:[s("W12A","mm",60,1,500,1),s("W22A","mm",60,1,500,1),s("W12B","mm",60,1,500,1),z("Side"),s("L11","mm",50,1,500,1),s("L12","mm",50,1,500,1),s("L21","mm",50,1,500,1),s("L22","mm",50,1,500,1),s("D1","mm",40,1,200,1),s("S1","mm",10,1,200,1),z("Axis"),s("Taxis","mm",3,.5,10,.25),s("D2axis","mm",10,0,200,1),s("D3axis","mm",20,0,200,1),z("Hollow"),s("D12","mm",20,0,200,1),s("D13A","mm",30,0,200,1),s("D13B","mm",30,0,200,1),s("D22","mm",20,0,200,1),s("D23A","mm",30,0,200,1),s("D23B","mm",30,0,200,1),z("Thickness and corners"),s("T1","mm",3,.5,10,.25),s("J1mark","mm",1,0,20,.1),s("J1radius","mm",5,0,50,1),s("J1neutral","%",50,0,100,1),s("T2","mm",3,.5,10,.25),s("J2mark","mm",1,0,20,.1),s("J2radius","mm",5,0,50,1),s("J2neutral","%",50,0,100,1),s("E12","mm",1,0,10,.1),z("Joint angle"),s("JointA","degree",0,-90,90,1)],paramSvg:{W12A:"armJoint_section.svg",W22A:"armJoint_section.svg",W12B:"armJoint_section.svg",L11:"armJoint_side.svg",L12:"armJoint_side.svg",D1:"armJoint_side.svg",S1:"armJoint_side.svg",Taxis:"armJoint_side.svg",D2axis:"armJoint_side.svg",D3axis:"armJoint_side.svg",D12:"armJoint_side.svg",D13A:"armJoint_side.svg",D13B:"armJoint_top.svg",D22:"armJoint_side.svg",D23A:"armJoint_side.svg",D23B:"armJoint_top.svg",T1:"armJoint_top.svg",T2:"armJoint_top.svg",J1mark:"armJoint_section.svg",J1radius:"armJoint_section.svg",J1neutral:"armJoint_section.svg",J2mark:"armJoint_section.svg",J2radius:"armJoint_section.svg",J2neutral:"armJoint_section.svg",E12:"armJoint_section.svg",JointA:"armJoint_side.svg"},sim:{tMax:360,tStep:1,tUpdate:500}};function hn(o){let t=o;return o>90&&(o<270?t=180-o:t=o-360),t}function Sn(o,t,i=""){const e=ft(go.partName+i),n=O(),c=O(),g=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const d=t.J1neutral/100,r=t.J2neutral/100,l=t.J1radius+t.T1*(1-d),f=t.J2radius+t.T2*(1-r),h=t.W12A-2*l,S=t.W12B-2*l,A=t.W22A-2*f,u=t.W12B-2*t.T1-2*t.E12,x=u-2*f,$=t.L11+t.L12+t.D1/2+t.S1,D=t.L21+t.L22+t.D1/2+t.S1,J=t.L11+t.L12+t.L21+t.L22,m=hn(t.JointA+o),_=p(m);if(h<=0)throw`err150: W11A ${h} is negative because of J1Rext ${a(l)}`;if(S<=0)throw`err153: W11B ${S} is negative because of J1Rext ${a(l)}`;if(A<=0)throw`err156: W21A ${A} is negative because of J2Rext ${a(f)}`;if(x<=0)throw`err159: W21B ${x} is negative because of J2Rext ${a(f)}`;e.logstr+=`armEnd-1 W12A ${a(t.W12A)}, W12B ${a(t.W12B)}, L1total ${a($)}
`,e.logstr+=`armEnd-2 W22A ${a(t.W22A)}, W22B ${a(u)}, L2total ${a(D)}
`,e.logstr+=`L12total ${a(J)} mm
`,e.logstr+=`jointAngle ${a(m)} degree  ${a(_)} rad
`;const M=bt(Je.pDef);M.setVal("D1",t.D1),M.setVal("T1",t.Taxis),M.setVal("L1",t.W12B),M.setVal("D2",t.D2axis),M.setVal("D3",t.D3axis);const B=Je.pGeom(0,M.getParamVal(),M.getSuffix());vt(B),e.logstr+=Mt(B.logstr,M.getPartNameSuffix());const v=bt(jt.pDef,"1");v.setVal("W2A",t.W12A),v.setVal("W2B",t.W12B),v.setVal("eqWAB",0),v.setVal("L1",t.L11),v.setVal("L2",t.L12),v.setVal("D1",t.D1),v.setVal("S1",t.S1),v.setVal("D2",t.D12),v.setVal("D3A",t.D13A),v.setVal("D3B",t.D13B),v.setVal("T1",t.T1),v.setVal("Jmark",t.J1mark),v.setVal("Jradius",t.J1radius),v.setVal("Jneutral",t.J1neutral);const C=jt.pGeom(0,v.getParamVal(),v.getSuffix());vt(C),e.logstr+=Mt(C.logstr,v.getPartNameSuffix());const y=bt(jt.pDef,"2");y.setVal("W2A",t.W22A),y.setVal("W2B",u),y.setVal("eqWAB",0),y.setVal("L1",t.L21),y.setVal("L2",t.L22),y.setVal("D1",t.D1),y.setVal("S1",t.S1),y.setVal("D2",t.D22),y.setVal("D3A",t.D23A),y.setVal("D3B",t.D23B),y.setVal("T1",t.T2),y.setVal("Jmark",t.J2mark),y.setVal("Jradius",t.J2radius),y.setVal("Jneutral",t.J2neutral);const E=jt.pGeom(0,y.getParamVal(),y.getSuffix());vt(E),e.logstr+=Mt(E.logstr,y.getPartNameSuffix());const k=Tt().addRotation(_+Math.PI/2).addTranslation(0,t.L11+t.L12),N=k.getRotation(),[T,w]=k.getTranslation(),L=Tt().addRotation(Math.PI).addTranslation(0,t.L21+t.L22).addRotation(_).addTranslation(0,t.L11+t.L12),F=L.getRotation(),[P,q]=L.getTranslation();n.mergeFigure(C.fig.faceSide),n.mergeFigure(B.fig.faceAxis.rotate(0,0,N).translate(T,w)),n.mergeFigure(E.fig.faceSide.rotate(0,0,F).translate(P,q));const V=t.L11+t.L12+t.L21+t.L22;c.mergeFigure(C.fig.faceTop),c.mergeFigure(E.fig.faceTop.rotate(0,0,Math.PI).translate(0,V)),c.mergeFigure(B.fig.faceHoleS.translate(0,t.L11+t.L12)),g.mergeFigure(B.fig.faceHoleS.rotate(0,0,Math.PI/2)),g.mergeFigure(C.fig.SFG_profiles.translate(-t.W12A/2+l,-t.W12B/2)),g.mergeFigure(E.fig.SFG_profiles.translate(-t.W22A/2+f,-u/2)),e.fig={faceSide:n,faceTop:c,faceSection:g};const R=Dt(),W=Dt().addRotation(0,0,Math.PI).addTranslation(0,t.L21+t.L22,0).addRotation(0,0,_).addTranslation(0,t.L11+t.L12,t.T1+t.E12),b=Dt().addRotation(0,0,_+Math.PI/2).addTranslation(0,t.L11+t.L12,0),U=e.partName;e.vol={inherits:[{outName:`inpax_${U}_end1`,subdesign:"pax_armEnd1",subgeom:C,rotate:R.getRotation(),translate:R.getTranslation()},{outName:`inpax_${U}_end2`,subdesign:"pax_armEnd2",subgeom:E,rotate:W.getRotation(),translate:W.getTranslation()},{outName:`inpax_${U}_axis`,subdesign:"pax_armAxis",subgeom:B,rotate:b.getRotation(),translate:b.getTranslation()}],extrudes:[],volumes:[{outName:`pax_${U}`,boolMethod:Rt.eUnion,inList:[`inpax_${U}_end1`,`inpax_${U}_end2`,`inpax_${U}_axis`]}]};const it={partName:v.getPartName(),dparam:v.getDesignParamList(),orientation:R.getRotation(),position:R.getTranslation()},lt={partName:y.getPartName(),dparam:y.getDesignParamList(),orientation:W.getRotation(),position:W.getTranslation()},tt={partName:M.getPartName(),dparam:M.getDesignParamList(),orientation:b.getRotation(),position:b.getTranslation()};e.sub={armEnd_1:it,armEnd_2:lt,armAxis_1:tt},e.logstr+=`armJoint drawn successfully!
`,e.calcErr=!1}catch(d){e.logstr+=d,console.log(d)}return e}var Rn={pTitle:"armJoint",pDescription:"robotic arm joint",pDef:go,pGeom:Sn},fo={partName:"armBone",params:[s("W2A","mm",60,1,500,1),s("W2B","mm",60,1,500,1),Ot("eqWAB",!0),ht("twist",["straight","twisted"]),z("Face"),s("L1","mm",50,1,500,1),s("L2","mm",50,1,500,1),s("D1","mm",40,1,200,1),s("S1","mm",10,1,200,1),s("L3","mm",50,1,500,1),s("D5","mm",40,1,200,1),s("S2","mm",10,1,200,1),z("Hollow"),s("D2","mm",20,0,200,1),s("D4","mm",20,0,200,1),s("D3A","mm",30,0,200,1),s("D3B","mm",30,0,200,1),z("Thickness and corners"),s("T1","mm",3,.5,10,.25),s("Jmark","mm",1,0,20,.1),s("Jradius","mm",5,0,50,1),s("Jneutral","%",50,0,100,1)],paramSvg:{W2A:"armBone_section.svg",W2B:"armBone_section.svg",eqWAB:"armBone_section.svg",twist:"armBone_twisted.svg",L1:"armBone_leg.svg",L2:"armBone_leg.svg",D1:"armBone_leg.svg",S1:"armBone_leg.svg",L3:"armBone_leg.svg",D5:"armBone_leg.svg",S2:"armBone_leg.svg",D2:"armBone_leg.svg",D4:"armBone_leg.svg",D3A:"armBone_leg.svg",D3B:"armBone_side.svg",T1:"armBone_section.svg",Jmark:"armBone_section.svg",Jradius:"armBone_section.svg",Jneutral:"armBone_section.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function Ee(o,t,i,e){const n=Math.sqrt(o**2+t**2),c=Math.atan2(t,o);let g=0;const d=.01;if(i>n+d)throw`err123: ${e} lDiag ${a(n)} too small compare to iRext ${a(i)}, iL2 ${a(o)} and iW1A2 ${a(t)}`;i<n-d&&(g=Math.acos(i/n));const r=-Math.PI/2+c+g,l=i*Math.cos(r),f=i*Math.sin(r);return[l,f]}function An(o,t,i=""){const e=ft(fo.partName+i),n=O(),c=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{let r=function(st,_t){const nt=K(-B,0);return _t===1?nt.addSegStrokeR(J,0):nt.addSegStrokeAifBig(-k,-t.L3-N,.1,!1).addPointA(0,-t.L3-u-t.S2).addPointA(k,-t.L3-N).addSegArc2().addSegStrokeAifBig(B,0,.1,!0),st.length>0&&nt.startJunction(st[0],I.eA,H.eABLeft),nt.addSegStrokeR(0,t.L1).addSegStrokeAifBig(C,t.L1+t.L2+y,.1,!1).addPointA(0,t.L1+t.L2+h+t.S1).addPointA(-C,t.L1+t.L2+y).addSegArc2().addSegStrokeAifBig(-B,t.L1,.1,!0),st.length>1&&nt.startJunction(st[1],I.eB,H.eABRight),nt.closeSegStroke(),nt},l=function(st,_t){const nt=K(-v,0);return _t===1?nt.addSegStrokeAifBig(-k,-t.L3-N,.1,!1).addPointA(0,-t.L3-u-t.S2).addPointA(k,-t.L3-N).addSegArc2().addSegStrokeAifBig(v,0,.1,!0):nt.addSegStrokeR(m,0),st.length>0&&nt.startJunction(st[0],I.eA,H.eABLeft),nt.addSegStrokeR(0,t.L1).addSegStrokeR(-m,0),st.length>1&&nt.startJunction(st[1],I.eB,H.eABRight),nt.closeSegStroke(),nt};var g=r,d=l;const f=t.Jneutral/100,h=t.D1/2,S=t.D2/2,A=t.D4/2,u=t.D5/2,x=t.D3A/2;let $=t.D3B/2;const D=t.Jradius+t.T1*(1-f),J=t.W2A-2*D;let m=t.W2B-2*D;t.eqWAB&&($=x,m=J);const _=m+2*D,M=Math.PI/2,B=J/2,v=m/2,[C,y]=Ee(t.L2,B,h+t.S1,"L2f"),E=(t.L2-h)/2,[k,N]=Ee(t.L3,t.twist===1?v:B,u+t.S2,"L3b"),T=(t.L3-u)/2,w=t.L1+t.L2+t.L3+h+t.S1+u+t.S2;if(J<t.D3A)throw`err118: W1A ${J} too small compare to D3A ${t.D3A}`;if(t.L1<t.D3A)throw`err119: param.L1 ${t.L1} too small compare to D3A ${t.D3A}`;if(m<t.D3B)throw`err121: W1B ${m} too small compare to D3B ${t.D3B}`;if(t.L1<t.D3B)throw`err122: param.L1 ${t.L1} too small compare to D3B ${t.D3B}`;if(t.L2<h+2*S)throw`err124: L2 ${t.L2} too small compare to D1 ${t.D1} and D2 ${t.D2}`;if(t.L3<u+2*A)throw`err127: L3 ${t.L3} too small compare to D5 ${t.D5} and D4 ${t.D4}`;e.logstr+=`W1A ${a(J)}, W1B ${a(m)}
`,e.logstr+=`Y-length ${a(w)}
`;const L=[];x>0&&L.push(G(0,t.L1/2,x)),h>0&&L.push(G(0,t.L1+t.L2,h)),S>0&&L.push(G(0,t.L1+E,S));const F=[];$>0&&F.push(G(0,t.L1/2,$)),u>0&&(t.twist===1?F.push(G(0,-t.L3,u)):L.push(G(0,-t.L3,u))),A>0&&(t.twist===1?F.push(G(0,-T,A)):L.push(G(0,-T,A)));const P=r(["J1"],t.twist),q=Y([P,...L]),V=l(["J2","J1"],t.twist),R=Y([V,...F]),W=r(["J3","J2"],t.twist),b=Y([W,...L]),U=l(["J4","J3"],t.twist),it=Y([U,...F]),lt=qt([q,R,b,it],{J1:{angle:M,radius:t.Jradius,neutral:f,mark:t.Jmark},J2:{angle:M,radius:t.Jradius,neutral:f,mark:t.Jmark},J3:{angle:M,radius:t.Jradius,neutral:f,mark:t.Jmark},J4:{angle:M,radius:t.Jradius,neutral:f,mark:t.Jmark}},[{x1:0,y1:0,a1:0,l1:J,ante:[],post:["J1",m,"J2",J,"J3",m,"J4"]}],t.T1,e.partName);n.mergeFigure(ce(q)),n.addSecond(j(-t.W2A/2,0,(t.W2A-J)/2,t.L1)),n.addSecond(j(J/2,0,(t.W2A-J)/2,t.L1));const tt=t.L3+u+t.S2;t.twist===1&&(n.addMainO(j(-t.W2A/2,-tt,t.T1,tt+t.L1)),n.addMainO(j(t.W2A/2-t.T1,-tt,t.T1,tt+t.L1))),c.mergeFigure(ce(R)),c.addSecond(j(-_/2,0,(_-m)/2,t.L1)),c.addSecond(j(m/2,0,(_-m)/2,t.L1));const ot=t.twist===1?0:tt,rt=t.L1+t.L2+h+t.S1;c.addMainO(j(-_/2,-ot,t.T1,ot+rt)),c.addMainO(j(_/2-t.T1,-ot,t.T1,ot+rt)),e.fig={faceA:n,faceB:c};const gt=lt.makeFigures(!0);for(const st of Object.keys(gt))e.fig[st]=gt[st];e.vol=lt.makeVolume(),e.sub={},e.logstr+=`armBone drawn successfully!
`,e.calcErr=!1}catch(r){e.logstr+=r,console.log(r)}return e}var Te={pTitle:"armBone",pDescription:"bone of robotic arm",pDef:fo,pGeom:An},uo={partName:"armChain",params:[s("jointNb","joints",1,1,10,1),ht("twist",["straight","twisted"]),s("D1hand","mm",10,1,200,1),s("progressionA","%",100,100,200,1),s("progressionB","mm",1,0,100,.1),z("Hand"),s("W2Ahand","mm",60,1,500,1),s("W2Bhand","mm",60,1,500,1),Ot("eqWAB",!0),s("S1hand","mm",10,1,200,1),z("Middle"),s("L1","mm",50,1,500,1),z("Thickness and corners"),s("T1","mm",3,.5,10,.25),s("Jmark","mm",1,0,20,.1),s("Jradius","mm",5,0,50,1),s("Jneutral","%",50,0,100,1),s("E12","mm",1,0,10,.1),z("Joint angle"),s("JointA0","degree",0,-90,90,1),s("JointA1","degree",0,-90,90,1),s("JointA2","degree",0,-90,90,1),s("JointA3","degree",0,-90,90,1),s("JointA4","degree",0,-90,90,1),s("JointA5","degree",0,-90,90,1),s("JointA6","degree",0,-90,90,1),s("JointA7","degree",0,-90,90,1),s("JointA8","degree",0,-90,90,1),s("JointA9","degree",0,-90,90,1)],paramSvg:{jointNb:"armChain_overview.svg",twist:"armChain_overview.svg",D1hand:"armChain_overview.svg",progressionA:"armChain_overview.svg",progressionB:"armChain_overview.svg",W2Ahand:"armChain_initSection.svg",W2Bhand:"armChain_initSection.svg",S1hand:"armChain_overview.svg",L1:"armChain_overview.svg",T1:"armChain_initSection.svg",Jmark:"armChain_initSection.svg",Jradius:"armChain_initSection.svg",Jneutral:"armChain_initSection.svg",E12:"armChain_initSection.svg",JointA0:"armChain_overview.svg",JointA1:"armChain_overview.svg",JointA2:"armChain_overview.svg",JointA3:"armChain_overview.svg",JointA4:"armChain_overview.svg",JointA5:"armChain_overview.svg",JointA6:"armChain_overview.svg",JointA7:"armChain_overview.svg",JointA8:"armChain_overview.svg",JointA9:"armChain_overview.svg"},sim:{tMax:360,tStep:1,tUpdate:500}};function Ct(o){let t=o;return o>90&&(o<270?t=180-o:t=o-360),t}function Ne(o,t,i){const e=Math.min(o-i,t-i*.01);return Math.max(e,0)}function we(o,t,i){let e=o;const n=(o+t)*1.01,c=Math.sqrt(n**2-o**2);return i<c&&(e=Math.sqrt(n**2-i**2)),e}function Fe(o,t,i){return i?o[t].fig.faceB:o[t].fig.faceA}function Ie(o,t){return t?o.fig.faceTop:o.fig.faceSide}function xn(o,t,i=""){const e=ft(uo.partName+i),n=O(),c=O(),g=O();e.logstr+=`${e.partName} simTime: ${o}
`;try{const d=t.Jneutral/100,r=t.Jradius+t.T1*(1-d),l=t.W2Ahand-2*r;let f=t.W2Bhand-2*r;t.eqWAB&&(f=l);const h=[];h.push(p(Ct(t.JointA0+o))),h.push(p(Ct(t.JointA1+o))),h.push(p(Ct(t.JointA2+o))),h.push(p(Ct(t.JointA3+o))),h.push(p(Ct(t.JointA4+o))),h.push(p(Ct(t.JointA5+o))),h.push(p(Ct(t.JointA6+o))),h.push(p(Ct(t.JointA7+o))),h.push(p(Ct(t.JointA8+o))),h.push(p(Ct(t.JointA9+o)));const S=[{W1A2:l/2,W1B2:f/2,R1:t.D1hand/2,S1:t.S1hand,L1:t.L1,L2b:we(t.D1hand/2,t.S1hand,l/2),L2f:0,twisted:t.twist===1&&t.jointNb%2===0}],A=t.progressionA/100;for(let R=1;R<t.jointNb+1;R++){let W=!1,b=!1;t.twist===1&&(R===1?(W=S[R-1].twisted,b=!1):(W=!S[R-1].twisted,b=!0));const U=b?S[R-1].W1B2:S[R-1].W1A2,it=b?S[R-1].W1A2:S[R-1].W1B2,lt=U*A+t.progressionB,tt=it+t.T1+t.E12,ot=S[R-1].R1*A+t.progressionB,rt=S[R-1].S1*A+t.progressionB,gt=t.L1,st=Math.max(U+r,S[R-1].R1+S[R-1].S1),_t={W1A2:lt,W1B2:tt,R1:ot,S1:rt,L1:gt,L2b:we(ot,rt,t.twist===1?tt:lt),L2f:st,twisted:W};S.push(_t)}const u=[];for(let R=0;R<t.jointNb+1;R++){const W={W1A2:S[t.jointNb-R].W1A2,W1B2:S[t.jointNb-R].W1B2,R1:S[t.jointNb-R].R1,S1:S[t.jointNb-R].S1,L1:S[t.jointNb-R].L1,L2b:S[t.jointNb-R].L2b,L2f:S[t.jointNb-R].L2f,twisted:S[t.jointNb-R].twisted,D3A:0,D3B:0,t2dA:Tt(),t2dB:Tt(),t2dC:Tt(),t3d:Dt()};u.push(W)}if(u[0].twisted)throw`dbg280: shoulderEnd should not be twisted ${u[0].twisted}`;for(let R=0;R<t.jointNb+1;R++){const W=Math.max(R-1,0);u[R].D3A=Ne(t.L1,u[R].W1A2*2,S[W].S1),u[R].D3B=Ne(t.L1,u[R].W1B2*2,S[W].S1),u[R].t2dC.addTranslation(-u[R].W1A2,-u[R].W1B2-r).addRotation(u[R].twisted?Math.PI/2:0);for(let b=R;b>0;b--)u[R].t2dA.addTranslation(0,u[b].L2b),u[b-1].twisted||u[R].t2dA.addRotation(h[b-1]),u[R].t2dA.addTranslation(0,u[b-1].L1+u[b-1].L2f),u[R].t2dB.addTranslation(0,u[b].L2b),u[b-1].twisted&&u[R].t2dB.addRotation(h[b-1]),u[R].t2dB.addTranslation(0,u[b-1].L1+u[b-1].L2f),t.twist===1&&b<t.jointNb&&u[R].t3d.addTranslation(0,0,-u[b].W1B2-r).addRotation(0,Math.PI/2,0).addTranslation(0,0,u[b].W1A2+r),u[R].t3d.addTranslation(0,u[b].L2b,0).addRotation(0,0,h[b-1]).addTranslation(0,u[b-1].L1+u[b-1].L2f,t.T1+t.E12)}if(l<=0)throw`err150: W1A ${l} is negative because of JRext ${a(r)}`;if(f<=0)throw`err153: W1B ${f} is negative because of JRext ${a(r)}`;e.logstr+=`arm twist: ${t.twist} joint-nb: ${t.jointNb}
`,e.logstr+=`hand armEnd W2Ahand ${a(t.W2Ahand)}, W2Bhand ${a(t.W2Bhand)} mm
`,e.logstr+=`shoulder armEnd W2A ${a((u[0].W1A2+r)*2)}, W2B ${a((u[0].W1B2+r)*2)} mm
`,e.logstr+=`shoulder armEnd L1 ${a(u[0].L1)}, L2 ${a(u[0].L2f)}, D1 ${a(u[1].R1*2)}, S1 ${a(u[1].S1)} mm
`;const x=bt(jt.pDef,"1");x.setVal("W2A",(u[0].W1A2+r)*2),x.setVal("W2B",(u[0].W1B2+r)*2),x.setVal("eqWAB",0),x.setVal("L1",u[0].L1),x.setVal("L2",u[0].L2f),x.setVal("D1",u[1].R1*2),x.setVal("S1",u[1].S1),x.setVal("D2",0),x.setVal("D3A",u[0].D3A),x.setVal("D3B",u[0].D3B),x.setVal("T1",t.T1),x.setVal("Jmark",t.Jmark),x.setVal("Jradius",t.Jradius),x.setVal("Jneutral",t.Jneutral);const $=jt.pGeom(0,x.getParamVal(),x.getSuffix());vt($),e.logstr+=Mt($.logstr,x.getPartNameSuffix());const D=bt(jt.pDef,"2");D.setVal("W2A",(u[t.jointNb].W1A2+r)*2),D.setVal("W2B",(u[t.jointNb].W1B2+r)*2),D.setVal("eqWAB",0),D.setVal("L1",u[t.jointNb].L1),D.setVal("L2",u[t.jointNb].L2b),D.setVal("D1",u[t.jointNb].R1*2),D.setVal("S1",u[t.jointNb].S1),D.setVal("D2",0),D.setVal("D3A",u[t.jointNb].D3A),D.setVal("D3B",u[t.jointNb].D3B),D.setVal("T1",t.T1),D.setVal("Jmark",t.Jmark),D.setVal("Jradius",t.Jradius),D.setVal("Jneutral",t.Jneutral);const J=jt.pGeom(0,D.getParamVal(),D.getSuffix());vt(J),e.logstr+=Mt(J.logstr,D.getPartNameSuffix());const m=[],_=[];for(let R=1;R<t.jointNb;R++){const W=bt(Te.pDef,(R-1).toString());W.setVal("W2A",(u[R].W1A2+r)*2),W.setVal("W2B",(u[R].W1B2+r)*2),W.setVal("eqWAB",0),W.setVal("twist",t.twist),W.setVal("L1",u[R].L1),W.setVal("L2",u[R].L2f),W.setVal("D1",u[R+1].R1*2),W.setVal("S1",u[R+1].S1),W.setVal("L3",u[R].L2b),W.setVal("D5",u[R].R1*2),W.setVal("S2",u[R].S1),W.setVal("D2",0),W.setVal("D4",0),W.setVal("D3A",u[R].D3A),W.setVal("D3B",u[R].D3B),W.setVal("T1",t.T1),W.setVal("Jmark",t.Jmark),W.setVal("Jradius",t.Jradius),W.setVal("Jneutral",t.Jneutral);const b=Te.pGeom(0,W.getParamVal(),W.getSuffix());vt(b),e.logstr+=Mt(b.logstr,W.getPartNameSuffix()),m.push(W),_.push(b)}n.mergeFigure($.fig.faceSide);for(let R=1;R<t.jointNb;R++){const W=u[R].t2dA.getRotation(),[b,U]=u[R].t2dA.getTranslation();n.mergeFigure(Fe(_,R-1,u[R].twisted).rotate(0,0,W).translate(b,U))}const M=Tt().addRotation(Math.PI).addTranslation(0,t.L1).addRotation(u[t.jointNb].t2dA.getRotation()).addTranslation(...u[t.jointNb].t2dA.getTranslation()),B=M.getRotation(),[v,C]=M.getTranslation();n.mergeFigure(Ie(J,u[t.jointNb-1].twisted).rotate(0,0,B).translate(v,C)),c.mergeFigure($.fig.faceTop);for(let R=1;R<t.jointNb;R++){const W=u[R].t2dB.getRotation(),[b,U]=u[R].t2dB.getTranslation();c.mergeFigure(Fe(_,R-1,!u[R].twisted).rotate(0,0,W).translate(b,U))}const y=Tt().addRotation(Math.PI).addTranslation(0,t.L1).addRotation(u[t.jointNb].t2dB.getRotation()).addTranslation(...u[t.jointNb].t2dB.getTranslation()),E=y.getRotation(),[k,N]=y.getTranslation();c.mergeFigure(Ie(J,!u[t.jointNb-1].twisted).rotate(0,0,E).translate(k,N)),g.mergeFigure($.fig.SFG_profiles.rotate(0,0,u[0].t2dC.getRotation()).translate(...u[0].t2dC.getTranslation()));for(let R=1;R<t.jointNb;R++)g.mergeFigure(_[R-1].fig.SFG_profiles.rotate(0,0,u[R].t2dC.getRotation()).translate(...u[R].t2dC.getTranslation()));g.mergeFigure(J.fig.SFG_profiles.rotate(0,0,u[t.jointNb].t2dC.getRotation()).translate(...u[t.jointNb].t2dC.getTranslation())),e.fig={faceA:n,faceB:c,faceSection:g};const T=Dt(),w=Dt().addRotation(0,0,Math.PI).addTranslation(0,t.L1,0).addRotation(...u[t.jointNb].t3d.getRotation()).addTranslation(...u[t.jointNb].t3d.getTranslation()),L=e.partName,F=[],P=[];for(let R=1;R<t.jointNb;R++){const W={outName:`inpax_${L}_bone${R-1}`,subdesign:`pax_armBone${R-1}`,subgeom:_[R-1],rotate:u[R].t3d.getRotation(),translate:u[R].t3d.getTranslation()};F.push(W),P.push(`inpax_${L}_bone${R-1}`)}e.vol={inherits:[{outName:`inpax_${L}_end1`,subdesign:"pax_armEnd1",subgeom:$,rotate:T.getRotation(),translate:T.getTranslation()},{outName:`inpax_${L}_end2`,subdesign:"pax_armEnd2",subgeom:J,rotate:w.getRotation(),translate:w.getTranslation()},...F],extrudes:[],volumes:[{outName:`pax_${L}`,boolMethod:Rt.eUnion,inList:[`inpax_${L}_end1`,`inpax_${L}_end2`,...P]}]};const q={partName:x.getPartName(),dparam:x.getDesignParamList(),orientation:T.getRotation(),position:T.getTranslation()},V={partName:D.getPartName(),dparam:D.getDesignParamList(),orientation:w.getRotation(),position:w.getTranslation()};e.sub={armEnd_1:q,armEnd_2:V};for(let R=1;R<t.jointNb;R++){const W={partName:m[R-1].getPartName(),dparam:m[R-1].getDesignParamList(),orientation:u[R].t3d.getRotation(),position:u[R].t3d.getTranslation()};e.sub[`armBone_${R-1}`]=W}e.logstr+=`armChain drawn successfully!
`,e.calcErr=!1}catch(d){e.logstr+=d,console.log(d)}return e}var _n={pTitle:"armChain",pDescription:"robotic arm composed of a chain or armBones",pDef:uo,pGeom:xn};const ho={"desi78/door":ko,"desi78/maison":yo,"desi78/cabane_plancher":ye,"desi78/cabane":bo,"desi78/reinforced_tube":le,"desi78/reinforced_cone":Co,"desi78/sfDie":No,"desi78/sfTube":Fo,"desi78/multiFacets":Ho,"desi78/sfCheck":jo,"desi78/lens_x1":Kt,"desi78/lens_x3":Yo,"desi78/pulley":tn,"desi78/codeExample1":sn,"desi78/demoTriangule":cn,"desi78/demoSheetFold":ln,"desi78/demoSheetFold2":gn,"desi78/armEnd":jt,"desi78/armAxis":Je,"desi78/armJoint":Rn,"desi78/armBone":Te,"desi78/armChain":_n,"desi78/rail":on};function Ln(o){const t=/^.*\//g;return o.replace(t,"")}function $n(o){const t={};for(const i of Object.keys(o)){const e=Ln(i);t[e]=`/${i}`}return t}function Dn(o){const t=[];for(const i of Object.keys(o))t.push(i);return t}const kn=$n(ho),Wn=Dn(ho);export{ho as a,kn as b,Wn as d};
